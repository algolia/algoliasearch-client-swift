// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
// https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import Foundation
#if canImport(AlgoliaCore)
    import AlgoliaCore
#endif

public struct Log: Codable, JSONEncodable {
    /// Date and time of the API request, in RFC 3339 format.
    public var timestamp: String
    /// HTTP method of the request.
    public var method: String
    /// HTTP status code of the response.
    public var answerCode: String
    /// Request body.
    public var queryBody: String
    /// Response body.
    public var answer: String
    /// URL of the API endpoint.
    public var url: String
    /// IP address of the client that performed the request.
    public var ip: String
    /// Request headers (API keys are obfuscated).
    public var queryHeaders: String
    /// SHA1 signature of the log entry.
    public var sha1: String
    /// Number of API requests.
    public var nbApiCalls: String?
    /// Processing time for the query in milliseconds. This doesn't include latency due to the network.
    public var processingTimeMs: String
    /// Index targeted by the query.
    public var index: String?
    /// Query parameters sent with the request.
    public var queryParams: String?
    /// Number of search results (hits) returned for the query.
    public var queryNbHits: String?
    /// Queries performed for the given request.
    public var innerQueries: [LogQuery]?

    public init(
        timestamp: String,
        method: String,
        answerCode: String,
        queryBody: String,
        answer: String,
        url: String,
        ip: String,
        queryHeaders: String,
        sha1: String,
        nbApiCalls: String? = nil,
        processingTimeMs: String,
        index: String? = nil,
        queryParams: String? = nil,
        queryNbHits: String? = nil,
        innerQueries: [LogQuery]? = nil
    ) {
        self.timestamp = timestamp
        self.method = method
        self.answerCode = answerCode
        self.queryBody = queryBody
        self.answer = answer
        self.url = url
        self.ip = ip
        self.queryHeaders = queryHeaders
        self.sha1 = sha1
        self.nbApiCalls = nbApiCalls
        self.processingTimeMs = processingTimeMs
        self.index = index
        self.queryParams = queryParams
        self.queryNbHits = queryNbHits
        self.innerQueries = innerQueries
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case timestamp
        case method
        case answerCode = "answer_code"
        case queryBody = "query_body"
        case answer
        case url
        case ip
        case queryHeaders = "query_headers"
        case sha1
        case nbApiCalls = "nb_api_calls"
        case processingTimeMs = "processing_time_ms"
        case index
        case queryParams = "query_params"
        case queryNbHits = "query_nb_hits"
        case innerQueries = "inner_queries"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.timestamp, forKey: .timestamp)
        try container.encode(self.method, forKey: .method)
        try container.encode(self.answerCode, forKey: .answerCode)
        try container.encode(self.queryBody, forKey: .queryBody)
        try container.encode(self.answer, forKey: .answer)
        try container.encode(self.url, forKey: .url)
        try container.encode(self.ip, forKey: .ip)
        try container.encode(self.queryHeaders, forKey: .queryHeaders)
        try container.encode(self.sha1, forKey: .sha1)
        try container.encodeIfPresent(self.nbApiCalls, forKey: .nbApiCalls)
        try container.encode(self.processingTimeMs, forKey: .processingTimeMs)
        try container.encodeIfPresent(self.index, forKey: .index)
        try container.encodeIfPresent(self.queryParams, forKey: .queryParams)
        try container.encodeIfPresent(self.queryNbHits, forKey: .queryNbHits)
        try container.encodeIfPresent(self.innerQueries, forKey: .innerQueries)
    }
}

extension Log: Equatable {
    public static func ==(lhs: Log, rhs: Log) -> Bool {
        lhs.timestamp == rhs.timestamp &&
            lhs.method == rhs.method &&
            lhs.answerCode == rhs.answerCode &&
            lhs.queryBody == rhs.queryBody &&
            lhs.answer == rhs.answer &&
            lhs.url == rhs.url &&
            lhs.ip == rhs.ip &&
            lhs.queryHeaders == rhs.queryHeaders &&
            lhs.sha1 == rhs.sha1 &&
            lhs.nbApiCalls == rhs.nbApiCalls &&
            lhs.processingTimeMs == rhs.processingTimeMs &&
            lhs.index == rhs.index &&
            lhs.queryParams == rhs.queryParams &&
            lhs.queryNbHits == rhs.queryNbHits &&
            lhs.innerQueries == rhs.innerQueries
    }
}

extension Log: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.timestamp.hashValue)
        hasher.combine(self.method.hashValue)
        hasher.combine(self.answerCode.hashValue)
        hasher.combine(self.queryBody.hashValue)
        hasher.combine(self.answer.hashValue)
        hasher.combine(self.url.hashValue)
        hasher.combine(self.ip.hashValue)
        hasher.combine(self.queryHeaders.hashValue)
        hasher.combine(self.sha1.hashValue)
        hasher.combine(self.nbApiCalls?.hashValue)
        hasher.combine(self.processingTimeMs.hashValue)
        hasher.combine(self.index?.hashValue)
        hasher.combine(self.queryParams?.hashValue)
        hasher.combine(self.queryNbHits?.hashValue)
        hasher.combine(self.innerQueries?.hashValue)
    }
}
