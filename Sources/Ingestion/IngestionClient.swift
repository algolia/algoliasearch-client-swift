// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
// https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import Foundation
#if canImport(Core)
    import Core
#endif

open class IngestionClient {
    private var configuration: IngestionClientConfiguration
    private var transporter: Transporter

    var appID: String {
        self.configuration.appID
    }

    public init(configuration: IngestionClientConfiguration, transporter: Transporter) {
        self.configuration = configuration
        self.transporter = transporter
    }

    public convenience init(configuration: IngestionClientConfiguration) {
        self.init(configuration: configuration, transporter: Transporter(configuration: configuration))
    }

    public convenience init(appID: String, apiKey: String, region: Region) throws {
        try self.init(configuration: IngestionClientConfiguration(appID: appID, apiKey: apiKey, region: region))
    }

    open func setClientApiKey(apiKey: String) {
        self.configuration.apiKey = apiKey
        self.transporter.setClientApiKey(apiKey: apiKey)
    }

    /// - parameter authenticationCreate: (body)
    /// - returns: AuthenticationCreateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func createAuthentication(
        authenticationCreate: AuthenticationCreate,
        requestOptions: RequestOptions? = nil
    ) async throws -> AuthenticationCreateResponse {
        let response: Response<AuthenticationCreateResponse> = try await createAuthenticationWithHTTPInfo(
            authenticationCreate: authenticationCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Creates a new authentication resource.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter authenticationCreate: (body)
    // - returns: RequestBuilder<AuthenticationCreateResponse>

    open func createAuthenticationWithHTTPInfo(
        authenticationCreate: AuthenticationCreate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AuthenticationCreateResponse> {
        let resourcePath = "/1/authentications"
        let body = authenticationCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter destinationCreate: (body)
    /// - returns: DestinationCreateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func createDestination(
        destinationCreate: DestinationCreate,
        requestOptions: RequestOptions? = nil
    ) async throws -> DestinationCreateResponse {
        let response: Response<DestinationCreateResponse> = try await createDestinationWithHTTPInfo(
            destinationCreate: destinationCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Creates a new destination.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter destinationCreate: (body)
    // - returns: RequestBuilder<DestinationCreateResponse>

    open func createDestinationWithHTTPInfo(
        destinationCreate: DestinationCreate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DestinationCreateResponse> {
        let resourcePath = "/1/destinations"
        let body = destinationCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter sourceCreate: (body)
    /// - returns: SourceCreateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func createSource(
        sourceCreate: SourceCreate,
        requestOptions: RequestOptions? = nil
    ) async throws -> SourceCreateResponse {
        let response: Response<SourceCreateResponse> = try await createSourceWithHTTPInfo(
            sourceCreate: sourceCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Creates a new source.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceCreate: (body)
    // - returns: RequestBuilder<SourceCreateResponse>

    open func createSourceWithHTTPInfo(
        sourceCreate: SourceCreate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SourceCreateResponse> {
        let resourcePath = "/1/sources"
        let body = sourceCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskCreate: (body) Request body for creating a task.
    /// - returns: TaskCreateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func createTask(
        taskCreate: TaskCreate,
        requestOptions: RequestOptions? = nil
    ) async throws -> TaskCreateResponse {
        let response: Response<TaskCreateResponse> = try await createTaskWithHTTPInfo(
            taskCreate: taskCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Creates a new task.
    //
    //
    // - parameter taskCreate: (body) Request body for creating a task.
    // - returns: RequestBuilder<TaskCreateResponse>

    open func createTaskWithHTTPInfo(
        taskCreate: TaskCreate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskCreateResponse> {
        let resourcePath = "/2/tasks"
        let body = taskCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskCreate: (body) Request body for creating a task.
    /// - returns: TaskCreateResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func createTaskV1(
        taskCreate: TaskCreateV1,
        requestOptions: RequestOptions? = nil
    ) async throws -> TaskCreateResponse {
        let response: Response<TaskCreateResponse> = try await createTaskV1WithHTTPInfo(
            taskCreate: taskCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Creates a new task using the v1 endpoint, please use `createTask` instead.
    ///
    ///
    /// - parameter taskCreate: (body) Request body for creating a task.
    /// - returns: RequestBuilder<TaskCreateResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func createTaskV1WithHTTPInfo(
        taskCreate: TaskCreateV1,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskCreateResponse> {
        let resourcePath = "/1/tasks"
        let body = taskCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter transformationCreate: (body) Request body for creating a transformation.
    /// - returns: TransformationCreateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func createTransformation(
        transformationCreate: TransformationCreate,
        requestOptions: RequestOptions? = nil
    ) async throws -> TransformationCreateResponse {
        let response: Response<TransformationCreateResponse> = try await createTransformationWithHTTPInfo(
            transformationCreate: transformationCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Creates a new transformation.
    //
    //
    // - parameter transformationCreate: (body) Request body for creating a transformation.
    // - returns: RequestBuilder<TransformationCreateResponse>

    open func createTransformationWithHTTPInfo(
        transformationCreate: TransformationCreate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TransformationCreateResponse> {
        let resourcePath = "/1/transformations"
        let body = transformationCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customDelete(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customDeleteWithHTTPInfo(
            path: path,
            parameters: parameters,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method lets you send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customDeleteWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customDelete")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customGet(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customGetWithHTTPInfo(
            path: path,
            parameters: parameters,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method lets you send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customGetWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customGet")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - parameter body: (body) Parameters to send with the custom request. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customPost(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customPostWithHTTPInfo(
            path: path,
            parameters: parameters,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method lets you send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    //
    // - parameter body: (body) Parameters to send with the custom request. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customPostWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customPost")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - parameter body: (body) Parameters to send with the custom request. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customPut(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customPutWithHTTPInfo(
            path: path,
            parameters: parameters,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method lets you send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    //
    // - parameter body: (body) Parameters to send with the custom request. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customPutWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customPut")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter authenticationID: (path) Unique identifier of an authentication resource.
    /// - returns: DeleteResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteAuthentication(
        authenticationID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> DeleteResponse {
        let response: Response<DeleteResponse> = try await deleteAuthenticationWithHTTPInfo(
            authenticationID: authenticationID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes an authentication resource. You can't delete authentication resources that are used by a source or a
    // destination.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter authenticationID: (path) Unique identifier of an authentication resource.
    // - returns: RequestBuilder<DeleteResponse>

    open func deleteAuthenticationWithHTTPInfo(
        authenticationID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteResponse> {
        guard !authenticationID.isEmpty else {
            throw AlgoliaError.invalidArgument("authenticationID", "deleteAuthentication")
        }

        var resourcePath = "/1/authentications/{authenticationID}"
        let authenticationIDPreEscape = "\(APIHelper.mapValueToPathItem(authenticationID))"
        let authenticationIDPostEscape = authenticationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{authenticationID}",
            with: authenticationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter destinationID: (path) Unique identifier of a destination.
    /// - returns: DeleteResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteDestination(
        destinationID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> DeleteResponse {
        let response: Response<DeleteResponse> = try await deleteDestinationWithHTTPInfo(
            destinationID: destinationID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter destinationID: (path) Unique identifier of a destination.
    // - returns: RequestBuilder<DeleteResponse>

    open func deleteDestinationWithHTTPInfo(
        destinationID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteResponse> {
        guard !destinationID.isEmpty else {
            throw AlgoliaError.invalidArgument("destinationID", "deleteDestination")
        }

        var resourcePath = "/1/destinations/{destinationID}"
        let destinationIDPreEscape = "\(APIHelper.mapValueToPathItem(destinationID))"
        let destinationIDPostEscape = destinationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{destinationID}",
            with: destinationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - returns: DeleteResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteSource(sourceID: String, requestOptions: RequestOptions? = nil) async throws -> DeleteResponse {
        let response: Response<DeleteResponse> = try await deleteSourceWithHTTPInfo(
            sourceID: sourceID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a source by its ID. You can't delete sources that are referenced in tasks.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    // - returns: RequestBuilder<DeleteResponse>

    open func deleteSourceWithHTTPInfo(
        sourceID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteResponse> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "deleteSource")
        }

        var resourcePath = "/1/sources/{sourceID}"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: DeleteResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteTask(taskID: String, requestOptions: RequestOptions? = nil) async throws -> DeleteResponse {
        let response: Response<DeleteResponse> = try await deleteTaskWithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a task by its ID.
    //
    //
    // - parameter taskID: (path) Unique identifier of a task.
    // - returns: RequestBuilder<DeleteResponse>

    open func deleteTaskWithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "deleteTask")
        }

        var resourcePath = "/2/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: DeleteResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteTaskV1(taskID: String, requestOptions: RequestOptions? = nil) async throws -> DeleteResponse {
        let response: Response<DeleteResponse> = try await deleteTaskV1WithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.
    ///
    ///
    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: RequestBuilder<DeleteResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func deleteTaskV1WithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "deleteTaskV1")
        }

        var resourcePath = "/1/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter transformationID: (path) Unique identifier of a transformation.
    /// - returns: DeleteResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteTransformation(
        transformationID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> DeleteResponse {
        let response: Response<DeleteResponse> = try await deleteTransformationWithHTTPInfo(
            transformationID: transformationID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a transformation by its ID.
    //
    //
    // - parameter transformationID: (path) Unique identifier of a transformation.
    // - returns: RequestBuilder<DeleteResponse>

    open func deleteTransformationWithHTTPInfo(
        transformationID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteResponse> {
        guard !transformationID.isEmpty else {
            throw AlgoliaError.invalidArgument("transformationID", "deleteTransformation")
        }

        var resourcePath = "/1/transformations/{transformationID}"
        let transformationIDPreEscape = "\(APIHelper.mapValueToPathItem(transformationID))"
        let transformationIDPostEscape = transformationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{transformationID}",
            with: transformationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: TaskUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func disableTask(taskID: String, requestOptions: RequestOptions? = nil) async throws -> TaskUpdateResponse {
        let response: Response<TaskUpdateResponse> = try await disableTaskWithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Disables a task.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskID: (path) Unique identifier of a task.
    // - returns: RequestBuilder<TaskUpdateResponse>

    open func disableTaskWithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskUpdateResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "disableTask")
        }

        var resourcePath = "/2/tasks/{taskID}/disable"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: TaskUpdateResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func disableTaskV1(taskID: String, requestOptions: RequestOptions? = nil) async throws -> TaskUpdateResponse {
        let response: Response<TaskUpdateResponse> = try await disableTaskV1WithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Disables a task using the v1 endpoint, please use `disableTask` instead.
    /// Required API Key ACLs:
    ///  - addObject
    ///  - deleteIndex
    ///  - editSettings
    ///
    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: RequestBuilder<TaskUpdateResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func disableTaskV1WithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskUpdateResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "disableTaskV1")
        }

        var resourcePath = "/1/tasks/{taskID}/disable"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: TaskUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func enableTask(taskID: String, requestOptions: RequestOptions? = nil) async throws -> TaskUpdateResponse {
        let response: Response<TaskUpdateResponse> = try await enableTaskWithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Enables a task.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskID: (path) Unique identifier of a task.
    // - returns: RequestBuilder<TaskUpdateResponse>

    open func enableTaskWithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskUpdateResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "enableTask")
        }

        var resourcePath = "/2/tasks/{taskID}/enable"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: TaskUpdateResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func enableTaskV1(taskID: String, requestOptions: RequestOptions? = nil) async throws -> TaskUpdateResponse {
        let response: Response<TaskUpdateResponse> = try await enableTaskV1WithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Enables a task using the v1 endpoint, please use `enableTask` instead.
    /// Required API Key ACLs:
    ///  - addObject
    ///  - deleteIndex
    ///  - editSettings
    ///
    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: RequestBuilder<TaskUpdateResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func enableTaskV1WithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskUpdateResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "enableTaskV1")
        }

        var resourcePath = "/1/tasks/{taskID}/enable"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter authenticationID: (path) Unique identifier of an authentication resource.
    /// - returns: Authentication
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getAuthentication(
        authenticationID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> Authentication {
        let response: Response<Authentication> = try await getAuthenticationWithHTTPInfo(
            authenticationID: authenticationID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves an authentication resource by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter authenticationID: (path) Unique identifier of an authentication resource.
    // - returns: RequestBuilder<Authentication>

    open func getAuthenticationWithHTTPInfo(
        authenticationID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Authentication> {
        guard !authenticationID.isEmpty else {
            throw AlgoliaError.invalidArgument("authenticationID", "getAuthentication")
        }

        var resourcePath = "/1/authentications/{authenticationID}"
        let authenticationIDPreEscape = "\(APIHelper.mapValueToPathItem(authenticationID))"
        let authenticationIDPostEscape = authenticationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{authenticationID}",
            with: authenticationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter destinationID: (path) Unique identifier of a destination.
    /// - returns: Destination
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getDestination(destinationID: String, requestOptions: RequestOptions? = nil) async throws -> Destination {
        let response: Response<Destination> = try await getDestinationWithHTTPInfo(
            destinationID: destinationID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a destination by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter destinationID: (path) Unique identifier of a destination.
    // - returns: RequestBuilder<Destination>

    open func getDestinationWithHTTPInfo(
        destinationID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Destination> {
        guard !destinationID.isEmpty else {
            throw AlgoliaError.invalidArgument("destinationID", "getDestination")
        }

        var resourcePath = "/1/destinations/{destinationID}"
        let destinationIDPreEscape = "\(APIHelper.mapValueToPathItem(destinationID))"
        let destinationIDPostEscape = destinationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{destinationID}",
            with: destinationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter runID: (path) Unique identifier of a task run.
    /// - parameter eventID: (path) Unique identifier of an event.
    /// - returns: IngestionEvent
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getEvent(
        runID: String,
        eventID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> IngestionEvent {
        let response: Response<IngestionEvent> = try await getEventWithHTTPInfo(
            runID: runID,
            eventID: eventID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a single task run event by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter runID: (path) Unique identifier of a task run.
    //
    // - parameter eventID: (path) Unique identifier of an event.
    // - returns: RequestBuilder<IngestionEvent>

    open func getEventWithHTTPInfo(
        runID: String,
        eventID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<IngestionEvent> {
        guard !runID.isEmpty else {
            throw AlgoliaError.invalidArgument("runID", "getEvent")
        }

        guard !eventID.isEmpty else {
            throw AlgoliaError.invalidArgument("eventID", "getEvent")
        }

        var resourcePath = "/1/runs/{runID}/events/{eventID}"
        let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
        let runIDPostEscape = runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{runID}",
            with: runIDPostEscape,
            options: .literal,
            range: nil
        )
        let eventIDPreEscape = "\(APIHelper.mapValueToPathItem(eventID))"
        let eventIDPostEscape = eventIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{eventID}",
            with: eventIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter runID: (path) Unique identifier of a task run.
    /// - returns: Run
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getRun(runID: String, requestOptions: RequestOptions? = nil) async throws -> Run {
        let response: Response<Run> = try await getRunWithHTTPInfo(runID: runID, requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieve a single task run by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter runID: (path) Unique identifier of a task run.
    // - returns: RequestBuilder<Run>

    open func getRunWithHTTPInfo(
        runID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Run> {
        guard !runID.isEmpty else {
            throw AlgoliaError.invalidArgument("runID", "getRun")
        }

        var resourcePath = "/1/runs/{runID}"
        let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
        let runIDPostEscape = runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{runID}",
            with: runIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - returns: IngestionSource
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getSource(sourceID: String, requestOptions: RequestOptions? = nil) async throws -> IngestionSource {
        let response: Response<IngestionSource> = try await getSourceWithHTTPInfo(
            sourceID: sourceID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieve a source by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    // - returns: RequestBuilder<IngestionSource>

    open func getSourceWithHTTPInfo(
        sourceID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<IngestionSource> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "getSource")
        }

        var resourcePath = "/1/sources/{sourceID}"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: IngestionTask
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getTask(taskID: String, requestOptions: RequestOptions? = nil) async throws -> IngestionTask {
        let response: Response<IngestionTask> = try await getTaskWithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a task by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskID: (path) Unique identifier of a task.
    // - returns: RequestBuilder<IngestionTask>

    open func getTaskWithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<IngestionTask> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "getTask")
        }

        var resourcePath = "/2/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: TaskV1
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getTaskV1(taskID: String, requestOptions: RequestOptions? = nil) async throws -> TaskV1 {
        let response: Response<TaskV1> = try await getTaskV1WithHTTPInfo(taskID: taskID, requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.
    /// Required API Key ACLs:
    ///  - addObject
    ///  - deleteIndex
    ///  - editSettings
    ///
    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: RequestBuilder<TaskV1>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func getTaskV1WithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskV1> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "getTaskV1")
        }

        var resourcePath = "/1/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter transformationID: (path) Unique identifier of a transformation.
    /// - returns: Transformation
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getTransformation(
        transformationID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> Transformation {
        let response: Response<Transformation> = try await getTransformationWithHTTPInfo(
            transformationID: transformationID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a transformation by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter transformationID: (path) Unique identifier of a transformation.
    // - returns: RequestBuilder<Transformation>

    open func getTransformationWithHTTPInfo(
        transformationID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Transformation> {
        guard !transformationID.isEmpty else {
            throw AlgoliaError.invalidArgument("transformationID", "getTransformation")
        }

        var resourcePath = "/1/transformations/{transformationID}"
        let transformationIDPreEscape = "\(APIHelper.mapValueToPathItem(transformationID))"
        let transformationIDPostEscape = transformationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{transformationID}",
            with: transformationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter type: (query) Type of authentication resource to retrieve. (optional)
    /// - parameter platform: (query) Ecommerce platform for which to retrieve authentications. (optional)
    /// - parameter sort: (query) Property by which to sort the list of authentications. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - returns: ListAuthenticationsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listAuthentications(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [AuthenticationType]? = nil,
        platform: [PlatformWithNone]? = nil,
        sort: AuthenticationSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListAuthenticationsResponse {
        let response: Response<ListAuthenticationsResponse> = try await listAuthenticationsWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            type: type,
            platform: platform,
            sort: sort,
            order: order,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of all authentication resources.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter type: (query) Type of authentication resource to retrieve. (optional)
    //
    // - parameter platform: (query) Ecommerce platform for which to retrieve authentications. (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of authentications. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    // - returns: RequestBuilder<ListAuthenticationsResponse>

    open func listAuthenticationsWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [AuthenticationType]? = nil,
        platform: [PlatformWithNone]? = nil,
        sort: AuthenticationSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListAuthenticationsResponse> {
        let resourcePath = "/1/authentications"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "type": type?.encodeToJSON(),
            "platform": platform?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter type: (query) Destination type. (optional)
    /// - parameter authenticationID: (query) Authentication ID used by destinations. (optional)
    /// - parameter transformationID: (query) Get the list of destinations used by a transformation. (optional)
    /// - parameter sort: (query) Property by which to sort the destinations. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - returns: ListDestinationsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listDestinations(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [DestinationType]? = nil,
        authenticationID: [String]? = nil,
        transformationID: String? = nil,
        sort: DestinationSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListDestinationsResponse {
        let response: Response<ListDestinationsResponse> = try await listDestinationsWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            type: type,
            authenticationID: authenticationID,
            transformationID: transformationID,
            sort: sort,
            order: order,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of destinations.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter type: (query) Destination type. (optional)
    //
    // - parameter authenticationID: (query) Authentication ID used by destinations. (optional)
    //
    // - parameter transformationID: (query) Get the list of destinations used by a transformation. (optional)
    //
    // - parameter sort: (query) Property by which to sort the destinations. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    // - returns: RequestBuilder<ListDestinationsResponse>

    open func listDestinationsWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [DestinationType]? = nil,
        authenticationID: [String]? = nil,
        transformationID: String? = nil,
        sort: DestinationSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListDestinationsResponse> {
        let resourcePath = "/1/destinations"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "type": type?.encodeToJSON(),
            "authenticationID": authenticationID?.encodeToJSON(),
            "transformationID": transformationID?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter runID: (path) Unique identifier of a task run.
    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter status: (query) Event status for filtering the list of task runs. (optional)
    /// - parameter type: (query) Event type for filtering the list of task runs. (optional)
    /// - parameter sort: (query) Property by which to sort the list of task run events. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - parameter startDate: (query) Date and time in RFC 3339 format for the earliest events to retrieve. By default,
    /// the current time minus three hours is used. (optional)
    /// - parameter endDate: (query) Date and time in RFC 3339 format for the latest events to retrieve. By default, the
    /// current time is used. (optional)
    /// - returns: ListEventsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listEvents(
        runID: String,
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        status: [IngestionEventStatus]? = nil,
        type: [IngestionEventType]? = nil,
        sort: EventSortKeys? = nil,
        order: OrderKeys? = nil,
        startDate: String? = nil,
        endDate: String? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListEventsResponse {
        let response: Response<ListEventsResponse> = try await listEventsWithHTTPInfo(
            runID: runID,
            itemsPerPage: itemsPerPage,
            page: page,
            status: status,
            type: type,
            sort: sort,
            order: order,
            startDate: startDate,
            endDate: endDate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of events for a task run, identified by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter runID: (path) Unique identifier of a task run.
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter status: (query) Event status for filtering the list of task runs. (optional)
    //
    // - parameter type: (query) Event type for filtering the list of task runs. (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of task run events. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    //
    // - parameter startDate: (query) Date and time in RFC 3339 format for the earliest events to retrieve. By default,
    // the current time minus three hours is used. (optional)
    //
    // - parameter endDate: (query) Date and time in RFC 3339 format for the latest events to retrieve. By default, the
    // current time is used. (optional)
    // - returns: RequestBuilder<ListEventsResponse>

    open func listEventsWithHTTPInfo(
        runID: String,
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        status: [IngestionEventStatus]? = nil,
        type: [IngestionEventType]? = nil,
        sort: EventSortKeys? = nil,
        order: OrderKeys? = nil,
        startDate: String? = nil,
        endDate: String? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListEventsResponse> {
        guard !runID.isEmpty else {
            throw AlgoliaError.invalidArgument("runID", "listEvents")
        }

        var resourcePath = "/1/runs/{runID}/events"
        let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
        let runIDPostEscape = runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{runID}",
            with: runIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "status": status?.encodeToJSON(),
            "type": type?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
            "startDate": startDate?.encodeToJSON(),
            "endDate": endDate?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter status: (query) Run status for filtering the list of task runs. (optional)
    /// - parameter type: (query) Run type for filtering the list of task runs. (optional)
    /// - parameter taskID: (query) Task ID for filtering the list of task runs. (optional)
    /// - parameter sort: (query) Property by which to sort the list of task runs. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - parameter startDate: (query) Date in RFC 3339 format for the earliest run to retrieve. By default, the current
    /// day minus seven days is used. (optional)
    /// - parameter endDate: (query) Date in RFC 3339 format for the latest run to retrieve. By default, the current day
    /// is used. (optional)
    /// - returns: RunListResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listRuns(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        status: [RunStatus]? = nil,
        type: [RunType]? = nil,
        taskID: String? = nil,
        sort: RunSortKeys? = nil,
        order: OrderKeys? = nil,
        startDate: String? = nil,
        endDate: String? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> RunListResponse {
        let response: Response<RunListResponse> = try await listRunsWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            status: status,
            type: type,
            taskID: taskID,
            sort: sort,
            order: order,
            startDate: startDate,
            endDate: endDate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieve a list of task runs.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter status: (query) Run status for filtering the list of task runs. (optional)
    //
    // - parameter type: (query) Run type for filtering the list of task runs. (optional)
    //
    // - parameter taskID: (query) Task ID for filtering the list of task runs. (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of task runs. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    //
    // - parameter startDate: (query) Date in RFC 3339 format for the earliest run to retrieve. By default, the current
    // day minus seven days is used. (optional)
    //
    // - parameter endDate: (query) Date in RFC 3339 format for the latest run to retrieve. By default, the current day
    // is used. (optional)
    // - returns: RequestBuilder<RunListResponse>

    open func listRunsWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        status: [RunStatus]? = nil,
        type: [RunType]? = nil,
        taskID: String? = nil,
        sort: RunSortKeys? = nil,
        order: OrderKeys? = nil,
        startDate: String? = nil,
        endDate: String? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<RunListResponse> {
        let resourcePath = "/1/runs"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "status": status?.encodeToJSON(),
            "type": type?.encodeToJSON(),
            "taskID": taskID?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
            "startDate": startDate?.encodeToJSON(),
            "endDate": endDate?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter type: (query) Source type. Some sources require authentication. (optional)
    /// - parameter authenticationID: (query) Authentication IDs of the sources to retrieve. 'none' returns sources that
    /// doesn't have an authentication.  (optional)
    /// - parameter sort: (query) Property by which to sort the list of sources. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - returns: ListSourcesResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listSources(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [SourceType]? = nil,
        authenticationID: [String]? = nil,
        sort: SourceSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListSourcesResponse {
        let response: Response<ListSourcesResponse> = try await listSourcesWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            type: type,
            authenticationID: authenticationID,
            sort: sort,
            order: order,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of sources.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter type: (query) Source type. Some sources require authentication. (optional)
    //
    // - parameter authenticationID: (query) Authentication IDs of the sources to retrieve. 'none' returns sources that
    // doesn't have an authentication.  (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of sources. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    // - returns: RequestBuilder<ListSourcesResponse>

    open func listSourcesWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [SourceType]? = nil,
        authenticationID: [String]? = nil,
        sort: SourceSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListSourcesResponse> {
        let resourcePath = "/1/sources"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "type": type?.encodeToJSON(),
            "authenticationID": authenticationID?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter action: (query) Actions for filtering the list of tasks. (optional)
    /// - parameter enabled: (query) Whether to filter the list of tasks by the `enabled` status. (optional)
    /// - parameter sourceID: (query) Source IDs for filtering the list of tasks. (optional)
    /// - parameter sourceType: (query) Filters the tasks with the specified source type. (optional)
    /// - parameter destinationID: (query) Destination IDs for filtering the list of tasks. (optional)
    /// - parameter triggerType: (query) Type of task trigger for filtering the list of tasks. (optional)
    /// - parameter withEmailNotifications: (query) If specified, the response only includes tasks with
    /// notifications.email.enabled set to this value. (optional)
    /// - parameter sort: (query) Property by which to sort the list of tasks. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - returns: ListTasksResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listTasks(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        action: [ActionType]? = nil,
        enabled: Bool? = nil,
        sourceID: [String]? = nil,
        sourceType: [SourceType]? = nil,
        destinationID: [String]? = nil,
        triggerType: [TriggerType]? = nil,
        withEmailNotifications: Bool? = nil,
        sort: TaskSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListTasksResponse {
        let response: Response<ListTasksResponse> = try await listTasksWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            action: action,
            enabled: enabled,
            sourceID: sourceID,
            sourceType: sourceType,
            destinationID: destinationID,
            triggerType: triggerType,
            withEmailNotifications: withEmailNotifications,
            sort: sort,
            order: order,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of tasks.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter action: (query) Actions for filtering the list of tasks. (optional)
    //
    // - parameter enabled: (query) Whether to filter the list of tasks by the `enabled` status. (optional)
    //
    // - parameter sourceID: (query) Source IDs for filtering the list of tasks. (optional)
    //
    // - parameter sourceType: (query) Filters the tasks with the specified source type. (optional)
    //
    // - parameter destinationID: (query) Destination IDs for filtering the list of tasks. (optional)
    //
    // - parameter triggerType: (query) Type of task trigger for filtering the list of tasks. (optional)
    //
    // - parameter withEmailNotifications: (query) If specified, the response only includes tasks with
    // notifications.email.enabled set to this value. (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of tasks. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    // - returns: RequestBuilder<ListTasksResponse>

    open func listTasksWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        action: [ActionType]? = nil,
        enabled: Bool? = nil,
        sourceID: [String]? = nil,
        sourceType: [SourceType]? = nil,
        destinationID: [String]? = nil,
        triggerType: [TriggerType]? = nil,
        withEmailNotifications: Bool? = nil,
        sort: TaskSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListTasksResponse> {
        let resourcePath = "/2/tasks"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "action": action?.encodeToJSON(),
            "enabled": enabled?.encodeToJSON(),
            "sourceID": sourceID?.encodeToJSON(),
            "sourceType": sourceType?.encodeToJSON(),
            "destinationID": destinationID?.encodeToJSON(),
            "triggerType": triggerType?.encodeToJSON(),
            "withEmailNotifications": withEmailNotifications?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter action: (query) Actions for filtering the list of tasks. (optional)
    /// - parameter enabled: (query) Whether to filter the list of tasks by the `enabled` status. (optional)
    /// - parameter sourceID: (query) Source IDs for filtering the list of tasks. (optional)
    /// - parameter destinationID: (query) Destination IDs for filtering the list of tasks. (optional)
    /// - parameter triggerType: (query) Type of task trigger for filtering the list of tasks. (optional)
    /// - parameter sort: (query) Property by which to sort the list of tasks. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - returns: ListTasksResponseV1
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listTasksV1(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        action: [ActionType]? = nil,
        enabled: Bool? = nil,
        sourceID: [String]? = nil,
        destinationID: [String]? = nil,
        triggerType: [TriggerType]? = nil,
        sort: TaskSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListTasksResponseV1 {
        let response: Response<ListTasksResponseV1> = try await listTasksV1WithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            action: action,
            enabled: enabled,
            sourceID: sourceID,
            destinationID: destinationID,
            triggerType: triggerType,
            sort: sort,
            order: order,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.
    /// Required API Key ACLs:
    ///  - addObject
    ///  - deleteIndex
    ///  - editSettings
    ///
    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    ///
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    ///
    /// - parameter action: (query) Actions for filtering the list of tasks. (optional)
    ///
    /// - parameter enabled: (query) Whether to filter the list of tasks by the `enabled` status. (optional)
    ///
    /// - parameter sourceID: (query) Source IDs for filtering the list of tasks. (optional)
    ///
    /// - parameter destinationID: (query) Destination IDs for filtering the list of tasks. (optional)
    ///
    /// - parameter triggerType: (query) Type of task trigger for filtering the list of tasks. (optional)
    ///
    /// - parameter sort: (query) Property by which to sort the list of tasks. (optional)
    ///
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - returns: RequestBuilder<ListTasksResponseV1>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func listTasksV1WithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        action: [ActionType]? = nil,
        enabled: Bool? = nil,
        sourceID: [String]? = nil,
        destinationID: [String]? = nil,
        triggerType: [TriggerType]? = nil,
        sort: TaskSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListTasksResponseV1> {
        let resourcePath = "/1/tasks"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "action": action?.encodeToJSON(),
            "enabled": enabled?.encodeToJSON(),
            "sourceID": sourceID?.encodeToJSON(),
            "destinationID": destinationID?.encodeToJSON(),
            "triggerType": triggerType?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter sort: (query) Property by which to sort the list of transformations. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - parameter type: (query) Whether to filter the list of transformations by the type of transformation.
    /// (optional)
    /// - returns: ListTransformationsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listTransformations(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        sort: TransformationSortKeys? = nil,
        order: OrderKeys? = nil,
        type: TransformationType? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListTransformationsResponse {
        let response: Response<ListTransformationsResponse> = try await listTransformationsWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            sort: sort,
            order: order,
            type: type,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of transformations.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of transformations. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    //
    // - parameter type: (query) Whether to filter the list of transformations by the type of transformation. (optional)
    // - returns: RequestBuilder<ListTransformationsResponse>

    open func listTransformationsWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        sort: TransformationSortKeys? = nil,
        order: OrderKeys? = nil,
        type: TransformationType? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListTransformationsResponse> {
        let resourcePath = "/1/transformations"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
            "type": type?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter pushTaskPayload: (body)
    /// - parameter watch: (query) When provided, the push operation will be synchronous and the API will wait for the
    /// ingestion to be finished before responding. (optional)
    /// - parameter referenceIndexName: (query) This is required when targeting an index that does not have a push
    /// connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source
    /// index name). (optional)
    /// - returns: IngestionWatchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func push(
        indexName: String,
        pushTaskPayload: PushTaskPayload,
        watch: Bool? = nil,
        referenceIndexName: String? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> IngestionWatchResponse {
        let response: Response<IngestionWatchResponse> = try await pushWithHTTPInfo(
            indexName: indexName,
            pushTaskPayload: pushTaskPayload,
            watch: watch,
            referenceIndexName: referenceIndexName,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Pushes records through the Pipeline, directly to an index. You can make the call synchronous by providing the
    // `watch` parameter, for asynchronous calls, you can use the observability endpoints and/or debugger dashboard to
    // see the status of your task. If you want to leverage the [pre-indexing data transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
    // this is the recommended way of ingesting your records. This method is similar to `pushTask`, but requires an
    // `indexName` instead of a `taskID`. If zero or many tasks are found, an error will be returned.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter pushTaskPayload: (body)
    //
    // - parameter watch: (query) When provided, the push operation will be synchronous and the API will wait for the
    // ingestion to be finished before responding. (optional)
    //
    // - parameter referenceIndexName: (query) This is required when targeting an index that does not have a push
    // connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source
    // index name). (optional)
    // - returns: RequestBuilder<IngestionWatchResponse>

    open func pushWithHTTPInfo(
        indexName: String,
        pushTaskPayload: PushTaskPayload,
        watch: Bool? = nil,
        referenceIndexName: String? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<IngestionWatchResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "push")
        }

        var resourcePath = "/1/push/{indexName}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = pushTaskPayload
        let queryParameters: [String: Any?] = [
            "watch": watch?.encodeToJSON(),
            "referenceIndexName": referenceIndexName?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters,
                readTimeout: 180,
                writeTimeout: 180
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - parameter pushTaskPayload: (body)
    /// - parameter watch: (query) When provided, the push operation will be synchronous and the API will wait for the
    /// ingestion to be finished before responding. (optional)
    /// - returns: IngestionWatchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func pushTask(
        taskID: String,
        pushTaskPayload: PushTaskPayload,
        watch: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> IngestionWatchResponse {
        let response: Response<IngestionWatchResponse> = try await pushTaskWithHTTPInfo(
            taskID: taskID,
            pushTaskPayload: pushTaskPayload,
            watch: watch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Pushes records through the pipeline, directly to an index. You can make the call synchronous by providing the
    // `watch` parameter, for asynchronous calls, you can use the observability endpoints or the debugger dashboard to
    // see the status of your task. If you want to transform your data before indexing, this is the recommended way of
    // ingesting your records. This method is similar to `push`, but requires a `taskID` instead of a `indexName`, which
    // is useful when many `destinations` target the same `indexName`.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskID: (path) Unique identifier of a task.
    //
    // - parameter pushTaskPayload: (body)
    //
    // - parameter watch: (query) When provided, the push operation will be synchronous and the API will wait for the
    // ingestion to be finished before responding. (optional)
    // - returns: RequestBuilder<IngestionWatchResponse>

    open func pushTaskWithHTTPInfo(
        taskID: String,
        pushTaskPayload: PushTaskPayload,
        watch: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<IngestionWatchResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "pushTask")
        }

        var resourcePath = "/2/tasks/{taskID}/push"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = pushTaskPayload
        let queryParameters: [String: Any?] = [
            "watch": watch?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters,
                readTimeout: 180,
                writeTimeout: 180
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - parameter taskReplace: (body)
    /// - returns: TaskUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func replaceTask(
        taskID: String,
        taskReplace: TaskReplace,
        requestOptions: RequestOptions? = nil
    ) async throws -> TaskUpdateResponse {
        let response: Response<TaskUpdateResponse> = try await replaceTaskWithHTTPInfo(
            taskID: taskID,
            taskReplace: taskReplace,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Fully updates a task by its ID, use partialUpdateTask if you only want to update a subset of fields.
    //
    //
    // - parameter taskID: (path) Unique identifier of a task.
    //
    // - parameter taskReplace: (body)
    // - returns: RequestBuilder<TaskUpdateResponse>

    open func replaceTaskWithHTTPInfo(
        taskID: String,
        taskReplace: TaskReplace,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskUpdateResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "replaceTask")
        }

        var resourcePath = "/2/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = taskReplace
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - parameter runSourcePayload: (body)  (optional)
    /// - returns: RunSourceResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func runSource(
        sourceID: String,
        runSourcePayload: RunSourcePayload? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> RunSourceResponse {
        let response: Response<RunSourceResponse> = try await runSourceWithHTTPInfo(
            sourceID: sourceID,
            runSourcePayload: runSourcePayload,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools sources. Creates one
    // run per task.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    //
    // - parameter runSourcePayload: (body)  (optional)
    // - returns: RequestBuilder<RunSourceResponse>

    open func runSourceWithHTTPInfo(
        sourceID: String,
        runSourcePayload: RunSourcePayload? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<RunSourceResponse> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "runSource")
        }

        var resourcePath = "/1/sources/{sourceID}/run"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = runSourcePayload
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - parameter runTaskPayload: (body)  (optional)
    /// - returns: RunResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func runTask(
        taskID: String,
        runTaskPayload: RunTaskPayload? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> RunResponse {
        let response: Response<RunResponse> = try await runTaskWithHTTPInfo(
            taskID: taskID,
            runTaskPayload: runTaskPayload,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Runs a task. You can check the status of task runs with the observability endpoints.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskID: (path) Unique identifier of a task.
    //
    // - parameter runTaskPayload: (body)  (optional)
    // - returns: RequestBuilder<RunResponse>

    open func runTaskWithHTTPInfo(
        taskID: String,
        runTaskPayload: RunTaskPayload? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<RunResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "runTask")
        }

        var resourcePath = "/2/tasks/{taskID}/run"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = runTaskPayload
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - parameter runTaskPayload: (body)  (optional)
    /// - returns: RunResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func runTaskV1(
        taskID: String,
        runTaskPayload: RunTaskPayload? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> RunResponse {
        let response: Response<RunResponse> = try await runTaskV1WithHTTPInfo(
            taskID: taskID,
            runTaskPayload: runTaskPayload,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of task runs with the
    /// observability endpoints.
    /// Required API Key ACLs:
    ///  - addObject
    ///  - deleteIndex
    ///  - editSettings
    ///
    /// - parameter taskID: (path) Unique identifier of a task.
    ///
    /// - parameter runTaskPayload: (body)  (optional)
    /// - returns: RequestBuilder<RunResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func runTaskV1WithHTTPInfo(
        taskID: String,
        runTaskPayload: RunTaskPayload? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<RunResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "runTaskV1")
        }

        var resourcePath = "/1/tasks/{taskID}/run"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = runTaskPayload
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter authenticationSearch: (body)
    /// - returns: [Authentication]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchAuthentications(
        authenticationSearch: AuthenticationSearch,
        requestOptions: RequestOptions? = nil
    ) async throws -> [Authentication] {
        let response: Response<[Authentication]> = try await searchAuthenticationsWithHTTPInfo(
            authenticationSearch: authenticationSearch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for authentication resources.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter authenticationSearch: (body)
    // - returns: RequestBuilder<[Authentication]>

    open func searchAuthenticationsWithHTTPInfo(
        authenticationSearch: AuthenticationSearch,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[Authentication]> {
        let resourcePath = "/1/authentications/search"
        let body = authenticationSearch
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter destinationSearch: (body)
    /// - returns: [Destination]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchDestinations(
        destinationSearch: DestinationSearch,
        requestOptions: RequestOptions? = nil
    ) async throws -> [Destination] {
        let response: Response<[Destination]> = try await searchDestinationsWithHTTPInfo(
            destinationSearch: destinationSearch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for destinations.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter destinationSearch: (body)
    // - returns: RequestBuilder<[Destination]>

    open func searchDestinationsWithHTTPInfo(
        destinationSearch: DestinationSearch,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[Destination]> {
        let resourcePath = "/1/destinations/search"
        let body = destinationSearch
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter sourceSearch: (body)
    /// - returns: [IngestionSource]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchSources(
        sourceSearch: SourceSearch,
        requestOptions: RequestOptions? = nil
    ) async throws -> [IngestionSource] {
        let response: Response<[IngestionSource]> = try await searchSourcesWithHTTPInfo(
            sourceSearch: sourceSearch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for sources.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceSearch: (body)
    // - returns: RequestBuilder<[IngestionSource]>

    open func searchSourcesWithHTTPInfo(
        sourceSearch: SourceSearch,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[IngestionSource]> {
        let resourcePath = "/1/sources/search"
        let body = sourceSearch
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskSearch: (body)
    /// - returns: [IngestionTask]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchTasks(
        taskSearch: TaskSearch,
        requestOptions: RequestOptions? = nil
    ) async throws -> [IngestionTask] {
        let response: Response<[IngestionTask]> = try await searchTasksWithHTTPInfo(
            taskSearch: taskSearch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for tasks.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskSearch: (body)
    // - returns: RequestBuilder<[IngestionTask]>

    open func searchTasksWithHTTPInfo(
        taskSearch: TaskSearch,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[IngestionTask]> {
        let resourcePath = "/2/tasks/search"
        let body = taskSearch
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskSearch: (body)
    /// - returns: [TaskV1]
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchTasksV1(taskSearch: TaskSearch, requestOptions: RequestOptions? = nil) async throws -> [TaskV1] {
        let response: Response<[TaskV1]> = try await searchTasksV1WithHTTPInfo(
            taskSearch: taskSearch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Searches for tasks using the v1 endpoint, please use `searchTasks` instead.
    /// Required API Key ACLs:
    ///  - addObject
    ///  - deleteIndex
    ///  - editSettings
    ///
    /// - parameter taskSearch: (body)
    /// - returns: RequestBuilder<[TaskV1]>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func searchTasksV1WithHTTPInfo(
        taskSearch: TaskSearch,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[TaskV1]> {
        let resourcePath = "/1/tasks/search"
        let body = taskSearch
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter transformationSearch: (body)
    /// - returns: [Transformation]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchTransformations(
        transformationSearch: TransformationSearch,
        requestOptions: RequestOptions? = nil
    ) async throws -> [Transformation] {
        let response: Response<[Transformation]> = try await searchTransformationsWithHTTPInfo(
            transformationSearch: transformationSearch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for transformations.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter transformationSearch: (body)
    // - returns: RequestBuilder<[Transformation]>

    open func searchTransformationsWithHTTPInfo(
        transformationSearch: TransformationSearch,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[Transformation]> {
        let resourcePath = "/1/transformations/search"
        let body = transformationSearch
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - returns: IngestionWatchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func triggerDockerSourceDiscover(
        sourceID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> IngestionWatchResponse {
        let response: Response<IngestionWatchResponse> = try await triggerDockerSourceDiscoverWithHTTPInfo(
            sourceID: sourceID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Triggers a stream-listing request for a source. Triggering stream-listing requests only works with sources with
    // `type: docker` and `imageType: airbyte`.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    // - returns: RequestBuilder<IngestionWatchResponse>

    open func triggerDockerSourceDiscoverWithHTTPInfo(
        sourceID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<IngestionWatchResponse> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "triggerDockerSourceDiscover")
        }

        var resourcePath = "/1/sources/{sourceID}/discover"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters,
                readTimeout: 180,
                writeTimeout: 180
            ) + userRequestOptions
        )
    }

    /// - parameter transformationTry: (body)
    /// - returns: TransformationTryResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func tryTransformation(
        transformationTry: TransformationTry,
        requestOptions: RequestOptions? = nil
    ) async throws -> TransformationTryResponse {
        let response: Response<TransformationTryResponse> = try await tryTransformationWithHTTPInfo(
            transformationTry: transformationTry,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Try a transformation before creating it.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter transformationTry: (body)
    // - returns: RequestBuilder<TransformationTryResponse>

    open func tryTransformationWithHTTPInfo(
        transformationTry: TransformationTry,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TransformationTryResponse> {
        let resourcePath = "/1/transformations/try"
        let body = transformationTry
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter transformationID: (path) Unique identifier of a transformation.
    /// - parameter transformationTry: (body)
    /// - returns: TransformationTryResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func tryTransformationBeforeUpdate(
        transformationID: String,
        transformationTry: TransformationTry,
        requestOptions: RequestOptions? = nil
    ) async throws -> TransformationTryResponse {
        let response: Response<TransformationTryResponse> = try await tryTransformationBeforeUpdateWithHTTPInfo(
            transformationID: transformationID,
            transformationTry: transformationTry,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Try a transformation before updating it.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter transformationID: (path) Unique identifier of a transformation.
    //
    // - parameter transformationTry: (body)
    // - returns: RequestBuilder<TransformationTryResponse>

    open func tryTransformationBeforeUpdateWithHTTPInfo(
        transformationID: String,
        transformationTry: TransformationTry,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TransformationTryResponse> {
        guard !transformationID.isEmpty else {
            throw AlgoliaError.invalidArgument("transformationID", "tryTransformationBeforeUpdate")
        }

        var resourcePath = "/1/transformations/{transformationID}/try"
        let transformationIDPreEscape = "\(APIHelper.mapValueToPathItem(transformationID))"
        let transformationIDPostEscape = transformationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{transformationID}",
            with: transformationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = transformationTry
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter authenticationID: (path) Unique identifier of an authentication resource.
    /// - parameter authenticationUpdate: (body)
    /// - returns: AuthenticationUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateAuthentication(
        authenticationID: String,
        authenticationUpdate: AuthenticationUpdate,
        requestOptions: RequestOptions? = nil
    ) async throws -> AuthenticationUpdateResponse {
        let response: Response<AuthenticationUpdateResponse> = try await updateAuthenticationWithHTTPInfo(
            authenticationID: authenticationID,
            authenticationUpdate: authenticationUpdate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Updates an authentication resource.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter authenticationID: (path) Unique identifier of an authentication resource.
    //
    // - parameter authenticationUpdate: (body)
    // - returns: RequestBuilder<AuthenticationUpdateResponse>

    open func updateAuthenticationWithHTTPInfo(
        authenticationID: String,
        authenticationUpdate: AuthenticationUpdate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AuthenticationUpdateResponse> {
        guard !authenticationID.isEmpty else {
            throw AlgoliaError.invalidArgument("authenticationID", "updateAuthentication")
        }

        var resourcePath = "/1/authentications/{authenticationID}"
        let authenticationIDPreEscape = "\(APIHelper.mapValueToPathItem(authenticationID))"
        let authenticationIDPostEscape = authenticationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{authenticationID}",
            with: authenticationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = authenticationUpdate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PATCH",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter destinationID: (path) Unique identifier of a destination.
    /// - parameter destinationUpdate: (body)
    /// - returns: DestinationUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateDestination(
        destinationID: String,
        destinationUpdate: DestinationUpdate,
        requestOptions: RequestOptions? = nil
    ) async throws -> DestinationUpdateResponse {
        let response: Response<DestinationUpdateResponse> = try await updateDestinationWithHTTPInfo(
            destinationID: destinationID,
            destinationUpdate: destinationUpdate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Updates the destination by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter destinationID: (path) Unique identifier of a destination.
    //
    // - parameter destinationUpdate: (body)
    // - returns: RequestBuilder<DestinationUpdateResponse>

    open func updateDestinationWithHTTPInfo(
        destinationID: String,
        destinationUpdate: DestinationUpdate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DestinationUpdateResponse> {
        guard !destinationID.isEmpty else {
            throw AlgoliaError.invalidArgument("destinationID", "updateDestination")
        }

        var resourcePath = "/1/destinations/{destinationID}"
        let destinationIDPreEscape = "\(APIHelper.mapValueToPathItem(destinationID))"
        let destinationIDPostEscape = destinationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{destinationID}",
            with: destinationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = destinationUpdate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PATCH",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - parameter sourceUpdate: (body)
    /// - returns: SourceUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateSource(
        sourceID: String,
        sourceUpdate: SourceUpdate,
        requestOptions: RequestOptions? = nil
    ) async throws -> SourceUpdateResponse {
        let response: Response<SourceUpdateResponse> = try await updateSourceWithHTTPInfo(
            sourceID: sourceID,
            sourceUpdate: sourceUpdate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Updates a source by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    //
    // - parameter sourceUpdate: (body)
    // - returns: RequestBuilder<SourceUpdateResponse>

    open func updateSourceWithHTTPInfo(
        sourceID: String,
        sourceUpdate: SourceUpdate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SourceUpdateResponse> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "updateSource")
        }

        var resourcePath = "/1/sources/{sourceID}"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = sourceUpdate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PATCH",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - parameter taskUpdate: (body)
    /// - returns: TaskUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateTask(
        taskID: String,
        taskUpdate: TaskUpdate,
        requestOptions: RequestOptions? = nil
    ) async throws -> TaskUpdateResponse {
        let response: Response<TaskUpdateResponse> = try await updateTaskWithHTTPInfo(
            taskID: taskID,
            taskUpdate: taskUpdate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Partially updates a task by its ID.
    //
    //
    // - parameter taskID: (path) Unique identifier of a task.
    //
    // - parameter taskUpdate: (body)
    // - returns: RequestBuilder<TaskUpdateResponse>

    open func updateTaskWithHTTPInfo(
        taskID: String,
        taskUpdate: TaskUpdate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskUpdateResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "updateTask")
        }

        var resourcePath = "/2/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = taskUpdate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PATCH",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - parameter taskUpdate: (body)
    /// - returns: TaskUpdateResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateTaskV1(
        taskID: String,
        taskUpdate: TaskUpdateV1,
        requestOptions: RequestOptions? = nil
    ) async throws -> TaskUpdateResponse {
        let response: Response<TaskUpdateResponse> = try await updateTaskV1WithHTTPInfo(
            taskID: taskID,
            taskUpdate: taskUpdate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.
    ///
    ///
    /// - parameter taskID: (path) Unique identifier of a task.
    ///
    /// - parameter taskUpdate: (body)
    /// - returns: RequestBuilder<TaskUpdateResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func updateTaskV1WithHTTPInfo(
        taskID: String,
        taskUpdate: TaskUpdateV1,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskUpdateResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "updateTaskV1")
        }

        var resourcePath = "/1/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = taskUpdate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PATCH",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter transformationID: (path) Unique identifier of a transformation.
    /// - parameter transformationCreate: (body)
    /// - returns: TransformationUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateTransformation(
        transformationID: String,
        transformationCreate: TransformationCreate,
        requestOptions: RequestOptions? = nil
    ) async throws -> TransformationUpdateResponse {
        let response: Response<TransformationUpdateResponse> = try await updateTransformationWithHTTPInfo(
            transformationID: transformationID,
            transformationCreate: transformationCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Updates a transformation by its ID.
    //
    //
    // - parameter transformationID: (path) Unique identifier of a transformation.
    //
    // - parameter transformationCreate: (body)
    // - returns: RequestBuilder<TransformationUpdateResponse>

    open func updateTransformationWithHTTPInfo(
        transformationID: String,
        transformationCreate: TransformationCreate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TransformationUpdateResponse> {
        guard !transformationID.isEmpty else {
            throw AlgoliaError.invalidArgument("transformationID", "updateTransformation")
        }

        var resourcePath = "/1/transformations/{transformationID}"
        let transformationIDPreEscape = "\(APIHelper.mapValueToPathItem(transformationID))"
        let transformationIDPostEscape = transformationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{transformationID}",
            with: transformationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = transformationCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter sourceCreate: (body)  (optional)
    /// - returns: IngestionWatchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func validateSource(
        sourceCreate: SourceCreate? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> IngestionWatchResponse {
        let response: Response<IngestionWatchResponse> = try await validateSourceWithHTTPInfo(
            sourceCreate: sourceCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceCreate: (body)  (optional)
    // - returns: RequestBuilder<IngestionWatchResponse>

    open func validateSourceWithHTTPInfo(
        sourceCreate: SourceCreate? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<IngestionWatchResponse> {
        let resourcePath = "/1/sources/validate"
        let body = sourceCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters,
                readTimeout: 180,
                writeTimeout: 180
            ) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - parameter sourceUpdate: (body)
    /// - returns: IngestionWatchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func validateSourceBeforeUpdate(
        sourceID: String,
        sourceUpdate: SourceUpdate,
        requestOptions: RequestOptions? = nil
    ) async throws -> IngestionWatchResponse {
        let response: Response<IngestionWatchResponse> = try await validateSourceBeforeUpdateWithHTTPInfo(
            sourceID: sourceID,
            sourceUpdate: sourceUpdate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Validates an update of a source payload to ensure it can be created and that the data source can be reached by
    // Algolia.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    //
    // - parameter sourceUpdate: (body)
    // - returns: RequestBuilder<IngestionWatchResponse>

    open func validateSourceBeforeUpdateWithHTTPInfo(
        sourceID: String,
        sourceUpdate: SourceUpdate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<IngestionWatchResponse> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "validateSourceBeforeUpdate")
        }

        var resourcePath = "/1/sources/{sourceID}/validate"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = sourceUpdate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters,
                readTimeout: 180,
                writeTimeout: 180
            ) + userRequestOptions
        )
    }
}
