// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import Core
import Foundation

#if canImport(AnyCodable)
  import AnyCodable
#endif

typealias Client = IngestionClient

open class IngestionClient {

  private var configuration: Configuration
  private var transporter: Transporter

  var applicationID: String {
    self.configuration.applicationID
  }

  public init(configuration: Configuration, transporter: Transporter) {
    self.configuration = configuration
    self.transporter = transporter
  }

  public convenience init(configuration: Configuration) {
    self.init(configuration: configuration, transporter: Transporter(configuration: configuration))
  }

  public convenience init(applicationID: String, apiKey: String, region: Region) {
    self.init(
      configuration: Configuration(applicationID: applicationID, apiKey: apiKey, region: region))
  }

  /**
     Create a authentication.

     - parameter authenticationCreate: (body)
     - returns: AuthenticationCreateResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func createAuthentication(
    authenticationCreate: AuthenticationCreate, requestOptions: RequestOptions? = nil
  ) async throws -> AuthenticationCreateResponse {
    return try await createAuthenticationWithHTTPInfo(
      authenticationCreate: authenticationCreate, requestOptions: requestOptions
    ).body
  }

  /**
     Create a authentication.

     Create a authentication.
     - parameter authenticationCreate: (body)
     - returns: RequestBuilder<AuthenticationCreateResponse>
     */

  open func createAuthenticationWithHTTPInfo(
    authenticationCreate: AuthenticationCreate,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<AuthenticationCreateResponse> {
    let path = "/1/authentications"
    let body = authenticationCreate

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Create a destination.

     - parameter destinationCreate: (body)
     - returns: DestinationCreateResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func createDestination(
    destinationCreate: DestinationCreate, requestOptions: RequestOptions? = nil
  ) async throws -> DestinationCreateResponse {
    return try await createDestinationWithHTTPInfo(
      destinationCreate: destinationCreate, requestOptions: requestOptions
    ).body
  }

  /**
     Create a destination.

     Create a destination.
     - parameter destinationCreate: (body)
     - returns: RequestBuilder<DestinationCreateResponse>
     */

  open func createDestinationWithHTTPInfo(
    destinationCreate: DestinationCreate, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<DestinationCreateResponse> {
    let path = "/1/destinations"
    let body = destinationCreate

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Create a source.

     - parameter sourceCreate: (body)
     - returns: SourceCreateResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func createSource(sourceCreate: SourceCreate, requestOptions: RequestOptions? = nil)
    async throws -> SourceCreateResponse
  {
    return try await createSourceWithHTTPInfo(
      sourceCreate: sourceCreate, requestOptions: requestOptions
    ).body
  }

  /**
     Create a source.

     Create a source.
     - parameter sourceCreate: (body)
     - returns: RequestBuilder<SourceCreateResponse>
     */

  open func createSourceWithHTTPInfo(
    sourceCreate: SourceCreate, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<SourceCreateResponse> {
    let path = "/1/sources"
    let body = sourceCreate

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Create a task.

     - parameter taskCreate: (body)
     - returns: TaskCreateResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func createTask(taskCreate: TaskCreate, requestOptions: RequestOptions? = nil) async throws
    -> TaskCreateResponse
  {
    return try await createTaskWithHTTPInfo(taskCreate: taskCreate, requestOptions: requestOptions)
      .body
  }

  /**
     Create a task.

     Create a task.
     - parameter taskCreate: (body)
     - returns: RequestBuilder<TaskCreateResponse>
     */

  open func createTaskWithHTTPInfo(
    taskCreate: TaskCreate, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<TaskCreateResponse> {
    let path = "/1/tasks"
    let body = taskCreate

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Send requests to the Algolia REST API.

     - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     - parameter parameters: (query) Query parameters to apply to the current query. (optional)
     - returns: AnyCodable
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func customDelete(
    path: String, parameters: [String: AnyCodable]? = nil, requestOptions: RequestOptions? = nil
  ) async throws -> AnyCodable {
    return try await customDeleteWithHTTPInfo(
      path: path, parameters: parameters, requestOptions: requestOptions
    ).body
  }

  /**
     Send requests to the Algolia REST API.

     This method allow you to send requests to the Algolia REST API.
     - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     - parameter parameters: (query) Query parameters to apply to the current query. (optional)
     - returns: RequestBuilder<AnyCodable>
     */

  open func customDeleteWithHTTPInfo(
    path: String, parameters: [String: AnyCodable]? = nil,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<AnyCodable> {
    var path = "/1{path}"
    let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
    let pathPostEscape =
      pathPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{path}", with: pathPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems = APIHelper.mapValuesToQueryItems([
      "parameters": (wrappedValue: parameters?.encodeToJSON(), isExplode: true)
    ])

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "DELETE",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Send requests to the Algolia REST API.

     - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     - parameter parameters: (query) Query parameters to apply to the current query. (optional)
     - returns: AnyCodable
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func customGet(
    path: String, parameters: [String: AnyCodable]? = nil, requestOptions: RequestOptions? = nil
  ) async throws -> AnyCodable {
    return try await customGetWithHTTPInfo(
      path: path, parameters: parameters, requestOptions: requestOptions
    ).body
  }

  /**
     Send requests to the Algolia REST API.

     This method allow you to send requests to the Algolia REST API.
     - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     - parameter parameters: (query) Query parameters to apply to the current query. (optional)
     - returns: RequestBuilder<AnyCodable>
     */

  open func customGetWithHTTPInfo(
    path: String, parameters: [String: AnyCodable]? = nil,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<AnyCodable> {
    var path = "/1{path}"
    let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
    let pathPostEscape =
      pathPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{path}", with: pathPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems = APIHelper.mapValuesToQueryItems([
      "parameters": (wrappedValue: parameters?.encodeToJSON(), isExplode: true)
    ])

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Send requests to the Algolia REST API.

     - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     - parameter parameters: (query) Query parameters to apply to the current query. (optional)
     - parameter body: (body) Parameters to send with the custom request. (optional)
     - returns: AnyCodable
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func customPost(
    path: String, parameters: [String: AnyCodable]? = nil, body: Codable? = nil,
    requestOptions: RequestOptions? = nil
  ) async throws -> AnyCodable {
    return try await customPostWithHTTPInfo(
      path: path, parameters: parameters, body: body, requestOptions: requestOptions
    ).body
  }

  /**
     Send requests to the Algolia REST API.

     This method allow you to send requests to the Algolia REST API.
     - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     - parameter parameters: (query) Query parameters to apply to the current query. (optional)
     - parameter body: (body) Parameters to send with the custom request. (optional)
     - returns: RequestBuilder<AnyCodable>
     */

  open func customPostWithHTTPInfo(
    path: String, parameters: [String: AnyCodable]? = nil, body: Codable? = nil,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<AnyCodable> {
    var path = "/1{path}"
    let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
    let pathPostEscape =
      pathPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{path}", with: pathPostEscape, options: .literal, range: nil)
    let body = body

    let queryItems = APIHelper.mapValuesToQueryItems([
      "parameters": (wrappedValue: parameters?.encodeToJSON(), isExplode: true)
    ])

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Send requests to the Algolia REST API.

     - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     - parameter parameters: (query) Query parameters to apply to the current query. (optional)
     - parameter body: (body) Parameters to send with the custom request. (optional)
     - returns: AnyCodable
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func customPut(
    path: String, parameters: [String: AnyCodable]? = nil, body: Codable? = nil,
    requestOptions: RequestOptions? = nil
  ) async throws -> AnyCodable {
    return try await customPutWithHTTPInfo(
      path: path, parameters: parameters, body: body, requestOptions: requestOptions
    ).body
  }

  /**
     Send requests to the Algolia REST API.

     This method allow you to send requests to the Algolia REST API.
     - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     - parameter parameters: (query) Query parameters to apply to the current query. (optional)
     - parameter body: (body) Parameters to send with the custom request. (optional)
     - returns: RequestBuilder<AnyCodable>
     */

  open func customPutWithHTTPInfo(
    path: String, parameters: [String: AnyCodable]? = nil, body: Codable? = nil,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<AnyCodable> {
    var path = "/1{path}"
    let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
    let pathPostEscape =
      pathPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{path}", with: pathPostEscape, options: .literal, range: nil)
    let body = body

    let queryItems = APIHelper.mapValuesToQueryItems([
      "parameters": (wrappedValue: parameters?.encodeToJSON(), isExplode: true)
    ])

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "PUT",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Delete a authentication.

     - parameter authenticationID: (path) The authentication UUID.
     - returns: DeleteResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func deleteAuthentication(authenticationID: String, requestOptions: RequestOptions? = nil)
    async throws -> DeleteResponse
  {
    return try await deleteAuthenticationWithHTTPInfo(
      authenticationID: authenticationID, requestOptions: requestOptions
    ).body
  }

  /**
     Delete a authentication.

     Soft delete the authentication of the given authenticationID.
     - parameter authenticationID: (path) The authentication UUID.
     - returns: RequestBuilder<DeleteResponse>
     */

  open func deleteAuthenticationWithHTTPInfo(
    authenticationID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<DeleteResponse> {
    var path = "/1/authentications/{authenticationID}"
    let authenticationIDPreEscape = "\(APIHelper.mapValueToPathItem(authenticationID))"
    let authenticationIDPostEscape =
      authenticationIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{authenticationID}", with: authenticationIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "DELETE",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Delete a destination.

     - parameter destinationID: (path) The destination UUID.
     - returns: DeleteResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func deleteDestination(destinationID: String, requestOptions: RequestOptions? = nil)
    async throws -> DeleteResponse
  {
    return try await deleteDestinationWithHTTPInfo(
      destinationID: destinationID, requestOptions: requestOptions
    ).body
  }

  /**
     Delete a destination.

     Soft delete the destination of the given destinationID.
     - parameter destinationID: (path) The destination UUID.
     - returns: RequestBuilder<DeleteResponse>
     */

  open func deleteDestinationWithHTTPInfo(
    destinationID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<DeleteResponse> {
    var path = "/1/destinations/{destinationID}"
    let destinationIDPreEscape = "\(APIHelper.mapValueToPathItem(destinationID))"
    let destinationIDPostEscape =
      destinationIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{destinationID}", with: destinationIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "DELETE",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Delete a source.

     - parameter sourceID: (path) The source UUID.
     - returns: DeleteResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func deleteSource(sourceID: String, requestOptions: RequestOptions? = nil) async throws
    -> DeleteResponse
  {
    return try await deleteSourceWithHTTPInfo(sourceID: sourceID, requestOptions: requestOptions)
      .body
  }

  /**
     Delete a source.

     Soft delete the source of the given sourceID.
     - parameter sourceID: (path) The source UUID.
     - returns: RequestBuilder<DeleteResponse>
     */

  open func deleteSourceWithHTTPInfo(
    sourceID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<DeleteResponse> {
    var path = "/1/sources/{sourceID}"
    let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
    let sourceIDPostEscape =
      sourceIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{sourceID}", with: sourceIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "DELETE",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Delete a task.

     - parameter taskID: (path) The task UUID.
     - returns: DeleteResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func deleteTask(taskID: String, requestOptions: RequestOptions? = nil) async throws
    -> DeleteResponse
  {
    return try await deleteTaskWithHTTPInfo(taskID: taskID, requestOptions: requestOptions).body
  }

  /**
     Delete a task.

     Soft delete the task of the given taskID.
     - parameter taskID: (path) The task UUID.
     - returns: RequestBuilder<DeleteResponse>
     */

  open func deleteTaskWithHTTPInfo(
    taskID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<DeleteResponse> {
    var path = "/1/tasks/{taskID}"
    let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
    let taskIDPostEscape =
      taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "DELETE",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Disable a task.

     - parameter taskID: (path) The task UUID.
     - returns: TaskUpdateResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func disableTask(taskID: String, requestOptions: RequestOptions? = nil) async throws
    -> TaskUpdateResponse
  {
    return try await disableTaskWithHTTPInfo(taskID: taskID, requestOptions: requestOptions).body
  }

  /**
     Disable a task.

     Disable the task of the given taskID.
     - parameter taskID: (path) The task UUID.
     - returns: RequestBuilder<TaskUpdateResponse>
     */

  open func disableTaskWithHTTPInfo(
    taskID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<TaskUpdateResponse> {
    var path = "/1/tasks/{taskID}/disable"
    let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
    let taskIDPostEscape =
      taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "PUT",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Enable a task.

     - parameter taskID: (path) The task UUID.
     - returns: TaskUpdateResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func enableTask(taskID: String, requestOptions: RequestOptions? = nil) async throws
    -> TaskUpdateResponse
  {
    return try await enableTaskWithHTTPInfo(taskID: taskID, requestOptions: requestOptions).body
  }

  /**
     Enable a task.

     Enable the task of the given taskID.
     - parameter taskID: (path) The task UUID.
     - returns: RequestBuilder<TaskUpdateResponse>
     */

  open func enableTaskWithHTTPInfo(
    taskID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<TaskUpdateResponse> {
    var path = "/1/tasks/{taskID}/enable"
    let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
    let taskIDPostEscape =
      taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "PUT",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a authentication.

     - parameter authenticationID: (path) The authentication UUID.
     - returns: Authentication
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getAuthentication(authenticationID: String, requestOptions: RequestOptions? = nil)
    async throws -> Authentication
  {
    return try await getAuthenticationWithHTTPInfo(
      authenticationID: authenticationID, requestOptions: requestOptions
    ).body
  }

  /**
     Get a authentication.

     Get the authentication of the given authenticationID.
     - parameter authenticationID: (path) The authentication UUID.
     - returns: RequestBuilder<Authentication>
     */

  open func getAuthenticationWithHTTPInfo(
    authenticationID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<Authentication> {
    var path = "/1/authentications/{authenticationID}"
    let authenticationIDPreEscape = "\(APIHelper.mapValueToPathItem(authenticationID))"
    let authenticationIDPostEscape =
      authenticationIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{authenticationID}", with: authenticationIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a list of authentications.

     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter type: (query) The type of the authentications to retrieve. (optional)
     - parameter platform: (query) The platform of the authentications to retrieve. (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - returns: ListAuthenticationsResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getAuthentications(
    itemsPerPage: Int? = nil, page: Int? = nil, type: [AuthenticationType]? = nil,
    platform: [PlatformWithNone]? = nil, sort: AuthenticationSortKeys? = nil,
    order: OrderKeys? = nil, requestOptions: RequestOptions? = nil
  ) async throws -> ListAuthenticationsResponse {
    return try await getAuthenticationsWithHTTPInfo(
      itemsPerPage: itemsPerPage, page: page, type: type, platform: platform, sort: sort,
      order: order, requestOptions: requestOptions
    ).body
  }

  /**
     Get a list of authentications.

     Get a list of authentications for the given query parameters, with pagination details.
     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter type: (query) The type of the authentications to retrieve. (optional)
     - parameter platform: (query) The platform of the authentications to retrieve. (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - returns: RequestBuilder<ListAuthenticationsResponse>
     */

  open func getAuthenticationsWithHTTPInfo(
    itemsPerPage: Int? = nil, page: Int? = nil, type: [AuthenticationType]? = nil,
    platform: [PlatformWithNone]? = nil, sort: AuthenticationSortKeys? = nil,
    order: OrderKeys? = nil, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<ListAuthenticationsResponse> {
    let path = "/1/authentications"
    let body: AnyCodable? = nil

    let queryItems = APIHelper.mapValuesToQueryItems([
      "itemsPerPage": (wrappedValue: itemsPerPage?.encodeToJSON(), isExplode: true),
      "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
      "type": (wrappedValue: type?.encodeToJSON(), isExplode: false),
      "platform": (wrappedValue: platform?.encodeToJSON(), isExplode: false),
      "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
      "order": (wrappedValue: order?.encodeToJSON(), isExplode: true),
    ])

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a destination.

     - parameter destinationID: (path) The destination UUID.
     - returns: Destination
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getDestination(destinationID: String, requestOptions: RequestOptions? = nil)
    async throws -> Destination
  {
    return try await getDestinationWithHTTPInfo(
      destinationID: destinationID, requestOptions: requestOptions
    ).body
  }

  /**
     Get a destination.

     Get the destination of the given destinationID.
     - parameter destinationID: (path) The destination UUID.
     - returns: RequestBuilder<Destination>
     */

  open func getDestinationWithHTTPInfo(
    destinationID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<Destination> {
    var path = "/1/destinations/{destinationID}"
    let destinationIDPreEscape = "\(APIHelper.mapValueToPathItem(destinationID))"
    let destinationIDPostEscape =
      destinationIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{destinationID}", with: destinationIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a list of destinations.

     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter type: (query) The type of the destinations to retrive. (optional)
     - parameter authenticationID: (query) The authenticationIDs of the destinations to retrive. (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - returns: ListDestinationsResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getDestinations(
    itemsPerPage: Int? = nil, page: Int? = nil, type: [DestinationType]? = nil,
    authenticationID: [String]? = nil, sort: DestinationSortKeys? = nil, order: OrderKeys? = nil,
    requestOptions: RequestOptions? = nil
  ) async throws -> ListDestinationsResponse {
    return try await getDestinationsWithHTTPInfo(
      itemsPerPage: itemsPerPage, page: page, type: type, authenticationID: authenticationID,
      sort: sort, order: order, requestOptions: requestOptions
    ).body
  }

  /**
     Get a list of destinations.

     Get a list of destinations for the given query parameters, with pagination details.
     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter type: (query) The type of the destinations to retrive. (optional)
     - parameter authenticationID: (query) The authenticationIDs of the destinations to retrive. (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - returns: RequestBuilder<ListDestinationsResponse>
     */

  open func getDestinationsWithHTTPInfo(
    itemsPerPage: Int? = nil, page: Int? = nil, type: [DestinationType]? = nil,
    authenticationID: [String]? = nil, sort: DestinationSortKeys? = nil, order: OrderKeys? = nil,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<ListDestinationsResponse> {
    let path = "/1/destinations"
    let body: AnyCodable? = nil

    let queryItems = APIHelper.mapValuesToQueryItems([
      "itemsPerPage": (wrappedValue: itemsPerPage?.encodeToJSON(), isExplode: true),
      "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
      "type": (wrappedValue: type?.encodeToJSON(), isExplode: false),
      "authenticationID": (wrappedValue: authenticationID?.encodeToJSON(), isExplode: false),
      "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
      "order": (wrappedValue: order?.encodeToJSON(), isExplode: true),
    ])

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Retrieve a stream listing.

     - parameter sourceID: (path) The source UUID.
     - returns: DockerSourceStreams
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getDockerSourceStreams(sourceID: String, requestOptions: RequestOptions? = nil)
    async throws -> DockerSourceStreams
  {
    return try await getDockerSourceStreamsWithHTTPInfo(
      sourceID: sourceID, requestOptions: requestOptions
    ).body
  }

  /**
     Retrieve a stream listing.

     Retrieve a stream listing for a given Singer specification compatible docker type source ID.
     - parameter sourceID: (path) The source UUID.
     - returns: RequestBuilder<DockerSourceStreams>
     */

  open func getDockerSourceStreamsWithHTTPInfo(
    sourceID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<DockerSourceStreams> {
    var path = "/1/sources/{sourceID}/discover"
    let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
    let sourceIDPostEscape =
      sourceIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{sourceID}", with: sourceIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get an event.

     - parameter runID: (path) The run UUID.
     - parameter eventID: (path) The event UUID.
     - returns: Event
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getEvent(runID: String, eventID: String, requestOptions: RequestOptions? = nil)
    async throws -> Event
  {
    return try await getEventWithHTTPInfo(
      runID: runID, eventID: eventID, requestOptions: requestOptions
    ).body
  }

  /**
     Get an event.

     Get a single event for a specific runID.
     - parameter runID: (path) The run UUID.
     - parameter eventID: (path) The event UUID.
     - returns: RequestBuilder<Event>
     */

  open func getEventWithHTTPInfo(
    runID: String, eventID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<Event> {
    var path = "/1/runs/{runID}/events/{eventID}"
    let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
    let runIDPostEscape =
      runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{runID}", with: runIDPostEscape, options: .literal, range: nil)
    let eventIDPreEscape = "\(APIHelper.mapValueToPathItem(eventID))"
    let eventIDPostEscape =
      eventIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{eventID}", with: eventIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a list of events.

     - parameter runID: (path) The run UUID.
     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter status: (query) Filter the status of the events. (optional)
     - parameter type: (query) Filter the type of the events. (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - parameter startDate: (query) The start date (in RFC3339 format) of the events fetching window. Defaults to &#39;now&#39;-3 hours if omitted. (optional)
     - parameter endDate: (query) The end date (in RFC3339 format) of the events fetching window. Defaults to &#39;now&#39; days if omitted. (optional)
     - returns: ListEventsResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getEvents(
    runID: String, itemsPerPage: Int? = nil, page: Int? = nil, status: [EventStatus]? = nil,
    type: [EventType]? = nil, sort: EventSortKeys? = nil, order: OrderKeys? = nil,
    startDate: String? = nil, endDate: String? = nil, requestOptions: RequestOptions? = nil
  ) async throws -> ListEventsResponse {
    return try await getEventsWithHTTPInfo(
      runID: runID, itemsPerPage: itemsPerPage, page: page, status: status, type: type, sort: sort,
      order: order, startDate: startDate, endDate: endDate, requestOptions: requestOptions
    ).body
  }

  /**
     Get a list of events.

     Get a list of events associated to the given runID, for the given query parameters.
     - parameter runID: (path) The run UUID.
     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter status: (query) Filter the status of the events. (optional)
     - parameter type: (query) Filter the type of the events. (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - parameter startDate: (query) The start date (in RFC3339 format) of the events fetching window. Defaults to &#39;now&#39;-3 hours if omitted. (optional)
     - parameter endDate: (query) The end date (in RFC3339 format) of the events fetching window. Defaults to &#39;now&#39; days if omitted. (optional)
     - returns: RequestBuilder<ListEventsResponse>
     */

  open func getEventsWithHTTPInfo(
    runID: String, itemsPerPage: Int? = nil, page: Int? = nil, status: [EventStatus]? = nil,
    type: [EventType]? = nil, sort: EventSortKeys? = nil, order: OrderKeys? = nil,
    startDate: String? = nil, endDate: String? = nil,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<ListEventsResponse> {
    var path = "/1/runs/{runID}/events"
    let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
    let runIDPostEscape =
      runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{runID}", with: runIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems = APIHelper.mapValuesToQueryItems([
      "itemsPerPage": (wrappedValue: itemsPerPage?.encodeToJSON(), isExplode: true),
      "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
      "status": (wrappedValue: status?.encodeToJSON(), isExplode: true),
      "type": (wrappedValue: type?.encodeToJSON(), isExplode: true),
      "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
      "order": (wrappedValue: order?.encodeToJSON(), isExplode: true),
      "startDate": (wrappedValue: startDate?.encodeToJSON(), isExplode: true),
      "endDate": (wrappedValue: endDate?.encodeToJSON(), isExplode: true),
    ])

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a run.

     - parameter runID: (path) The run UUID.
     - returns: Run
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getRun(runID: String, requestOptions: RequestOptions? = nil) async throws -> Run {
    return try await getRunWithHTTPInfo(runID: runID, requestOptions: requestOptions).body
  }

  /**
     Get a run.

     Get a single run for the given ID.
     - parameter runID: (path) The run UUID.
     - returns: RequestBuilder<Run>
     */

  open func getRunWithHTTPInfo(
    runID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<Run> {
    var path = "/1/runs/{runID}"
    let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
    let runIDPostEscape =
      runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{runID}", with: runIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a list of runs.

     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter status: (query) Filter the status of the runs. (optional)
     - parameter taskID: (query) Filter by taskID. (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - parameter startDate: (query) The start date (in RFC3339 format) of the runs fetching window. Defaults to &#39;now&#39;-7 days if omitted. (optional)
     - parameter endDate: (query) The end date (in RFC3339 format) of the runs fetching window. Defaults to &#39;now&#39; days if omitted. (optional)
     - returns: RunListResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getRuns(
    itemsPerPage: Int? = nil, page: Int? = nil, status: [RunStatus]? = nil, taskID: String? = nil,
    sort: RunSortKeys? = nil, order: OrderKeys? = nil, startDate: String? = nil,
    endDate: String? = nil, requestOptions: RequestOptions? = nil
  ) async throws -> RunListResponse {
    return try await getRunsWithHTTPInfo(
      itemsPerPage: itemsPerPage, page: page, status: status, taskID: taskID, sort: sort,
      order: order, startDate: startDate, endDate: endDate, requestOptions: requestOptions
    ).body
  }

  /**
     Get a list of runs.

     Get a list of runs for the given query parameters, with pagination details.
     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter status: (query) Filter the status of the runs. (optional)
     - parameter taskID: (query) Filter by taskID. (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - parameter startDate: (query) The start date (in RFC3339 format) of the runs fetching window. Defaults to &#39;now&#39;-7 days if omitted. (optional)
     - parameter endDate: (query) The end date (in RFC3339 format) of the runs fetching window. Defaults to &#39;now&#39; days if omitted. (optional)
     - returns: RequestBuilder<RunListResponse>
     */

  open func getRunsWithHTTPInfo(
    itemsPerPage: Int? = nil, page: Int? = nil, status: [RunStatus]? = nil, taskID: String? = nil,
    sort: RunSortKeys? = nil, order: OrderKeys? = nil, startDate: String? = nil,
    endDate: String? = nil, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<RunListResponse> {
    let path = "/1/runs"
    let body: AnyCodable? = nil

    let queryItems = APIHelper.mapValuesToQueryItems([
      "itemsPerPage": (wrappedValue: itemsPerPage?.encodeToJSON(), isExplode: true),
      "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
      "status": (wrappedValue: status?.encodeToJSON(), isExplode: true),
      "taskID": (wrappedValue: taskID?.encodeToJSON(), isExplode: true),
      "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
      "order": (wrappedValue: order?.encodeToJSON(), isExplode: true),
      "startDate": (wrappedValue: startDate?.encodeToJSON(), isExplode: true),
      "endDate": (wrappedValue: endDate?.encodeToJSON(), isExplode: true),
    ])

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a source.

     - parameter sourceID: (path) The source UUID.
     - returns: Source
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getSource(sourceID: String, requestOptions: RequestOptions? = nil) async throws
    -> Source
  {
    return try await getSourceWithHTTPInfo(sourceID: sourceID, requestOptions: requestOptions).body
  }

  /**
     Get a source.

     Get the source of the given sourceID.
     - parameter sourceID: (path) The source UUID.
     - returns: RequestBuilder<Source>
     */

  open func getSourceWithHTTPInfo(
    sourceID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<Source> {
    var path = "/1/sources/{sourceID}"
    let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
    let sourceIDPostEscape =
      sourceIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{sourceID}", with: sourceIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a list of sources.

     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter type: (query) The type of the sources to retrieve. (optional)
     - parameter authenticationID: (query) The authenticationIDs of the sources to retrieve. &#39;none&#39; returns sources that doesn&#39;t have an authentication.  (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - returns: ListSourcesResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getSources(
    itemsPerPage: Int? = nil, page: Int? = nil, type: [SourceType]? = nil,
    authenticationID: [String]? = nil, sort: SourceSortKeys? = nil, order: OrderKeys? = nil,
    requestOptions: RequestOptions? = nil
  ) async throws -> ListSourcesResponse {
    return try await getSourcesWithHTTPInfo(
      itemsPerPage: itemsPerPage, page: page, type: type, authenticationID: authenticationID,
      sort: sort, order: order, requestOptions: requestOptions
    ).body
  }

  /**
     Get a list of sources.

     Get a list of sources for the given query parameters, with pagination details.
     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter type: (query) The type of the sources to retrieve. (optional)
     - parameter authenticationID: (query) The authenticationIDs of the sources to retrieve. &#39;none&#39; returns sources that doesn&#39;t have an authentication.  (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - returns: RequestBuilder<ListSourcesResponse>
     */

  open func getSourcesWithHTTPInfo(
    itemsPerPage: Int? = nil, page: Int? = nil, type: [SourceType]? = nil,
    authenticationID: [String]? = nil, sort: SourceSortKeys? = nil, order: OrderKeys? = nil,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<ListSourcesResponse> {
    let path = "/1/sources"
    let body: AnyCodable? = nil

    let queryItems = APIHelper.mapValuesToQueryItems([
      "itemsPerPage": (wrappedValue: itemsPerPage?.encodeToJSON(), isExplode: true),
      "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
      "type": (wrappedValue: type?.encodeToJSON(), isExplode: false),
      "authenticationID": (wrappedValue: authenticationID?.encodeToJSON(), isExplode: false),
      "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
      "order": (wrappedValue: order?.encodeToJSON(), isExplode: true),
    ])

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a task.

     - parameter taskID: (path) The task UUID.
     - returns: Task
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getTask(taskID: String, requestOptions: RequestOptions? = nil) async throws -> Task {
    return try await getTaskWithHTTPInfo(taskID: taskID, requestOptions: requestOptions).body
  }

  /**
     Get a task.

     Get the task of the given taskID.
     - parameter taskID: (path) The task UUID.
     - returns: RequestBuilder<Task>
     */

  open func getTaskWithHTTPInfo(
    taskID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<Task> {
    var path = "/1/tasks/{taskID}"
    let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
    let taskIDPostEscape =
      taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Get a list of tasks.

     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter action: (query) The action of the tasks to retrieve. (optional)
     - parameter enabled: (query) Whether the task is enabled or not. (optional)
     - parameter sourceID: (query) The sourceIDs of the tasks to retrive. (optional)
     - parameter destinationID: (query) The destinationIDs of the tasks to retrive. (optional)
     - parameter triggerType: (query) The trigger type of the task. (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - returns: ListTasksResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func getTasks(
    itemsPerPage: Int? = nil, page: Int? = nil, action: [ActionType]? = nil, enabled: Bool? = nil,
    sourceID: [String]? = nil, destinationID: [String]? = nil, triggerType: [TriggerType]? = nil,
    sort: TaskSortKeys? = nil, order: OrderKeys? = nil, requestOptions: RequestOptions? = nil
  ) async throws -> ListTasksResponse {
    return try await getTasksWithHTTPInfo(
      itemsPerPage: itemsPerPage, page: page, action: action, enabled: enabled, sourceID: sourceID,
      destinationID: destinationID, triggerType: triggerType, sort: sort, order: order,
      requestOptions: requestOptions
    ).body
  }

  /**
     Get a list of tasks.

     Get a list of tasks for the given query parameters, with pagination details.
     - parameter itemsPerPage: (query) The number of items per page to return. (optional)
     - parameter page: (query) The page number to fetch, starting at 1. (optional)
     - parameter action: (query) The action of the tasks to retrieve. (optional)
     - parameter enabled: (query) Whether the task is enabled or not. (optional)
     - parameter sourceID: (query) The sourceIDs of the tasks to retrive. (optional)
     - parameter destinationID: (query) The destinationIDs of the tasks to retrive. (optional)
     - parameter triggerType: (query) The trigger type of the task. (optional)
     - parameter sort: (query) The key by which the list should be sorted. (optional)
     - parameter order: (query) The order of the returned list. (optional)
     - returns: RequestBuilder<ListTasksResponse>
     */

  open func getTasksWithHTTPInfo(
    itemsPerPage: Int? = nil, page: Int? = nil, action: [ActionType]? = nil, enabled: Bool? = nil,
    sourceID: [String]? = nil, destinationID: [String]? = nil, triggerType: [TriggerType]? = nil,
    sort: TaskSortKeys? = nil, order: OrderKeys? = nil,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<ListTasksResponse> {
    let path = "/1/tasks"
    let body: AnyCodable? = nil

    let queryItems = APIHelper.mapValuesToQueryItems([
      "itemsPerPage": (wrappedValue: itemsPerPage?.encodeToJSON(), isExplode: true),
      "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
      "action": (wrappedValue: action?.encodeToJSON(), isExplode: false),
      "enabled": (wrappedValue: enabled?.encodeToJSON(), isExplode: true),
      "sourceID": (wrappedValue: sourceID?.encodeToJSON(), isExplode: false),
      "destinationID": (wrappedValue: destinationID?.encodeToJSON(), isExplode: false),
      "triggerType": (wrappedValue: triggerType?.encodeToJSON(), isExplode: false),
      "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
      "order": (wrappedValue: order?.encodeToJSON(), isExplode: true),
    ])

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "GET",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Run a task.

     - parameter taskID: (path) The task UUID.
     - returns: RunResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func runTask(taskID: String, requestOptions: RequestOptions? = nil) async throws
    -> RunResponse
  {
    return try await runTaskWithHTTPInfo(taskID: taskID, requestOptions: requestOptions).body
  }

  /**
     Run a task.

     Run the task of the given taskID.
     - parameter taskID: (path) The task UUID.
     - returns: RequestBuilder<RunResponse>
     */

  open func runTaskWithHTTPInfo(
    taskID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<RunResponse> {
    var path = "/1/tasks/{taskID}/run"
    let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
    let taskIDPostEscape =
      taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Search among authentications.

     - parameter authenticationSearch: (body)
     - returns: [Authentication]
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func searchAuthentications(
    authenticationSearch: AuthenticationSearch, requestOptions: RequestOptions? = nil
  ) async throws -> [Authentication] {
    return try await searchAuthenticationsWithHTTPInfo(
      authenticationSearch: authenticationSearch, requestOptions: requestOptions
    ).body
  }

  /**
     Search among authentications.

     Search among authentications with a defined set of parameters.
     - parameter authenticationSearch: (body)
     - returns: RequestBuilder<[Authentication]>
     */

  open func searchAuthenticationsWithHTTPInfo(
    authenticationSearch: AuthenticationSearch,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<[Authentication]> {
    let path = "/1/authentications/search"
    let body = authenticationSearch

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Search among destinations.

     - parameter destinationSearch: (body)
     - returns: [Destination]
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func searchDestinations(
    destinationSearch: DestinationSearch, requestOptions: RequestOptions? = nil
  ) async throws -> [Destination] {
    return try await searchDestinationsWithHTTPInfo(
      destinationSearch: destinationSearch, requestOptions: requestOptions
    ).body
  }

  /**
     Search among destinations.

     Search among destinations with a defined set of parameters.
     - parameter destinationSearch: (body)
     - returns: RequestBuilder<[Destination]>
     */

  open func searchDestinationsWithHTTPInfo(
    destinationSearch: DestinationSearch, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<[Destination]> {
    let path = "/1/destinations/search"
    let body = destinationSearch

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Search among sources.

     - parameter sourceSearch: (body)
     - returns: [Source]
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func searchSources(sourceSearch: SourceSearch, requestOptions: RequestOptions? = nil)
    async throws -> [Source]
  {
    return try await searchSourcesWithHTTPInfo(
      sourceSearch: sourceSearch, requestOptions: requestOptions
    ).body
  }

  /**
     Search among sources.

     Search among sources with a defined set of parameters.
     - parameter sourceSearch: (body)
     - returns: RequestBuilder<[Source]>
     */

  open func searchSourcesWithHTTPInfo(
    sourceSearch: SourceSearch, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<[Source]> {
    let path = "/1/sources/search"
    let body = sourceSearch

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Search among tasks.

     - parameter taskSearch: (body)
     - returns: [Task]
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func searchTasks(taskSearch: TaskSearch, requestOptions: RequestOptions? = nil) async throws
    -> [Task]
  {
    return try await searchTasksWithHTTPInfo(taskSearch: taskSearch, requestOptions: requestOptions)
      .body
  }

  /**
     Search among tasks.

     Search among tasks with a defined set of parameters.
     - parameter taskSearch: (body)
     - returns: RequestBuilder<[Task]>
     */

  open func searchTasksWithHTTPInfo(
    taskSearch: TaskSearch, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<[Task]> {
    let path = "/1/tasks/search"
    let body = taskSearch

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Trigger a stream listing request.

     - parameter sourceID: (path) The source UUID.
     - returns: DockerSourceDiscover
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func triggerDockerSourceDiscover(sourceID: String, requestOptions: RequestOptions? = nil)
    async throws -> DockerSourceDiscover
  {
    return try await triggerDockerSourceDiscoverWithHTTPInfo(
      sourceID: sourceID, requestOptions: requestOptions
    ).body
  }

  /**
     Trigger a stream listing request.

     Trigger a stream listing request for a Singer specification compatible docker type source.
     - parameter sourceID: (path) The source UUID.
     - returns: RequestBuilder<DockerSourceDiscover>
     */

  open func triggerDockerSourceDiscoverWithHTTPInfo(
    sourceID: String, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<DockerSourceDiscover> {
    var path = "/1/sources/{sourceID}/discover"
    let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
    let sourceIDPostEscape =
      sourceIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{sourceID}", with: sourceIDPostEscape, options: .literal, range: nil)
    let body: AnyCodable? = nil

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "POST",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Update a authentication.

     - parameter authenticationID: (path) The authentication UUID.
     - parameter authenticationUpdate: (body)
     - returns: AuthenticationUpdateResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func updateAuthentication(
    authenticationID: String, authenticationUpdate: AuthenticationUpdate,
    requestOptions: RequestOptions? = nil
  ) async throws -> AuthenticationUpdateResponse {
    return try await updateAuthenticationWithHTTPInfo(
      authenticationID: authenticationID, authenticationUpdate: authenticationUpdate,
      requestOptions: requestOptions
    ).body
  }

  /**
     Update a authentication.

     Update the authentication of the given authenticationID.
     - parameter authenticationID: (path) The authentication UUID.
     - parameter authenticationUpdate: (body)
     - returns: RequestBuilder<AuthenticationUpdateResponse>
     */

  open func updateAuthenticationWithHTTPInfo(
    authenticationID: String, authenticationUpdate: AuthenticationUpdate,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<AuthenticationUpdateResponse> {
    var path = "/1/authentications/{authenticationID}"
    let authenticationIDPreEscape = "\(APIHelper.mapValueToPathItem(authenticationID))"
    let authenticationIDPostEscape =
      authenticationIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{authenticationID}", with: authenticationIDPostEscape, options: .literal, range: nil)
    let body = authenticationUpdate

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "PATCH",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Update a destination.

     - parameter destinationID: (path) The destination UUID.
     - parameter destinationUpdate: (body)
     - returns: DestinationUpdateResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func updateDestination(
    destinationID: String, destinationUpdate: DestinationUpdate,
    requestOptions: RequestOptions? = nil
  ) async throws -> DestinationUpdateResponse {
    return try await updateDestinationWithHTTPInfo(
      destinationID: destinationID, destinationUpdate: destinationUpdate,
      requestOptions: requestOptions
    ).body
  }

  /**
     Update a destination.

     Update the destination of the given destinationID.
     - parameter destinationID: (path) The destination UUID.
     - parameter destinationUpdate: (body)
     - returns: RequestBuilder<DestinationUpdateResponse>
     */

  open func updateDestinationWithHTTPInfo(
    destinationID: String, destinationUpdate: DestinationUpdate,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<DestinationUpdateResponse> {
    var path = "/1/destinations/{destinationID}"
    let destinationIDPreEscape = "\(APIHelper.mapValueToPathItem(destinationID))"
    let destinationIDPostEscape =
      destinationIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{destinationID}", with: destinationIDPostEscape, options: .literal, range: nil)
    let body = destinationUpdate

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "PATCH",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Update a source.

     - parameter sourceID: (path) The source UUID.
     - parameter sourceUpdate: (body)
     - returns: SourceUpdateResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func updateSource(
    sourceID: String, sourceUpdate: SourceUpdate, requestOptions: RequestOptions? = nil
  ) async throws -> SourceUpdateResponse {
    return try await updateSourceWithHTTPInfo(
      sourceID: sourceID, sourceUpdate: sourceUpdate, requestOptions: requestOptions
    ).body
  }

  /**
     Update a source.

     Update the source of the given sourceID.
     - parameter sourceID: (path) The source UUID.
     - parameter sourceUpdate: (body)
     - returns: RequestBuilder<SourceUpdateResponse>
     */

  open func updateSourceWithHTTPInfo(
    sourceID: String, sourceUpdate: SourceUpdate,
    requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<SourceUpdateResponse> {
    var path = "/1/sources/{sourceID}"
    let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
    let sourceIDPostEscape =
      sourceIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{sourceID}", with: sourceIDPostEscape, options: .literal, range: nil)
    let body = sourceUpdate

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "PATCH",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }

  /**
     Update a task.

     - parameter taskID: (path) The task UUID.
     - parameter taskUpdate: (body)
     - returns: TaskUpdateResponse
     */
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  open func updateTask(
    taskID: String, taskUpdate: TaskUpdate, requestOptions: RequestOptions? = nil
  ) async throws -> TaskUpdateResponse {
    return try await updateTaskWithHTTPInfo(
      taskID: taskID, taskUpdate: taskUpdate, requestOptions: requestOptions
    ).body
  }

  /**
     Update a task.

     Update the task of the given taskID.
     - parameter taskID: (path) The task UUID.
     - parameter taskUpdate: (body)
     - returns: RequestBuilder<TaskUpdateResponse>
     */

  open func updateTaskWithHTTPInfo(
    taskID: String, taskUpdate: TaskUpdate, requestOptions userRequestOptions: RequestOptions? = nil
  ) async throws -> Response<TaskUpdateResponse> {
    var path = "/1/tasks/{taskID}"
    let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
    let taskIDPostEscape =
      taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
    path = path.replacingOccurrences(
      of: "{taskID}", with: taskIDPostEscape, options: .literal, range: nil)
    let body = taskUpdate

    let queryItems: [URLQueryItem]? = nil

    let nillableHeaders: [String: Any?]? = [:]

    let headers = APIHelper.rejectNilHeaders(nillableHeaders)

    return try await self.transporter.send(
      method: "PATCH",
      path: path,
      data: body,
      requestOptions: RequestOptions(headers: headers, queryItems: queryItems) + userRequestOptions
    )
  }
}
