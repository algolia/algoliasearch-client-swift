// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
// https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import Foundation
#if canImport(AlgoliaCore)
    import AlgoliaCore
#endif

/// Configuration of an Algolia index for Query Suggestions.
public struct SourceIndex: Codable, JSONEncodable {
    /// Name of the Algolia index (case-sensitive) to use as source for query suggestions.
    public var indexName: String
    /// If true, Query Suggestions uses all replica indices to find popular searches. If false, only the primary index
    /// is used.
    public var replicas: Bool?
    public var analyticsTags: [String]?
    public var facets: [Facet]?
    /// Minimum number of hits required to be included as a suggestion.  A search query must at least generate `minHits`
    /// search results to be included in the Query Suggestions index.
    public var minHits: Int?
    /// Minimum letters required to be included as a suggestion.  A search query must be at least `minLetters` long to
    /// be included in the Query Suggestions index.
    public var minLetters: Int?
    public var generate: [[String]]?
    public var external: [String]?

    public init(
        indexName: String,
        replicas: Bool? = nil,
        analyticsTags: [String]? = nil,
        facets: [Facet]? = nil,
        minHits: Int? = nil,
        minLetters: Int? = nil,
        generate: [[String]]? = nil,
        external: [String]? = nil
    ) {
        self.indexName = indexName
        self.replicas = replicas
        self.analyticsTags = analyticsTags
        self.facets = facets
        self.minHits = minHits
        self.minLetters = minLetters
        self.generate = generate
        self.external = external
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case indexName
        case replicas
        case analyticsTags
        case facets
        case minHits
        case minLetters
        case generate
        case external
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.indexName, forKey: .indexName)
        try container.encodeIfPresent(self.replicas, forKey: .replicas)
        try container.encodeIfPresent(self.analyticsTags, forKey: .analyticsTags)
        try container.encodeIfPresent(self.facets, forKey: .facets)
        try container.encodeIfPresent(self.minHits, forKey: .minHits)
        try container.encodeIfPresent(self.minLetters, forKey: .minLetters)
        try container.encodeIfPresent(self.generate, forKey: .generate)
        try container.encodeIfPresent(self.external, forKey: .external)
    }
}

extension SourceIndex: Equatable {
    public static func ==(lhs: SourceIndex, rhs: SourceIndex) -> Bool {
        lhs.indexName == rhs.indexName &&
            lhs.replicas == rhs.replicas &&
            lhs.analyticsTags == rhs.analyticsTags &&
            lhs.facets == rhs.facets &&
            lhs.minHits == rhs.minHits &&
            lhs.minLetters == rhs.minLetters &&
            lhs.generate == rhs.generate &&
            lhs.external == rhs.external
    }
}

extension SourceIndex: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.indexName.hashValue)
        hasher.combine(self.replicas?.hashValue)
        hasher.combine(self.analyticsTags?.hashValue)
        hasher.combine(self.facets?.hashValue)
        hasher.combine(self.minHits?.hashValue)
        hasher.combine(self.minLetters?.hashValue)
        hasher.combine(self.generate?.hashValue)
        hasher.combine(self.external?.hashValue)
    }
}
