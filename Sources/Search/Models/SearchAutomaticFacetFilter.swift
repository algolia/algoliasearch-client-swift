// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
// https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import Foundation
#if canImport(AlgoliaCore)
    import AlgoliaCore
#endif

/// Filter or optional filter to be applied to the search.
public struct SearchAutomaticFacetFilter: Codable, JSONEncodable {
    /// Facet name to be applied as filter. The name must match placeholders in the `pattern` parameter. For example,
    /// with `pattern: {facet:genre}`, `automaticFacetFilters` must be `genre`.
    public var facet: String
    /// Filter scores to give different weights to individual filters.
    public var score: Int?
    /// Whether the filter is disjunctive or conjunctive.  If true the filter has multiple matches, multiple occurences
    /// are combined with the logical `OR` operation. If false, multiple occurences are combined with the logical `AND`
    /// operation.
    public var disjunctive: Bool?

    public init(facet: String, score: Int? = nil, disjunctive: Bool? = nil) {
        self.facet = facet
        self.score = score
        self.disjunctive = disjunctive
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case facet
        case score
        case disjunctive
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.facet, forKey: .facet)
        try container.encodeIfPresent(self.score, forKey: .score)
        try container.encodeIfPresent(self.disjunctive, forKey: .disjunctive)
    }
}

extension SearchAutomaticFacetFilter: Equatable {
    public static func ==(lhs: SearchAutomaticFacetFilter, rhs: SearchAutomaticFacetFilter) -> Bool {
        lhs.facet == rhs.facet &&
            lhs.score == rhs.score &&
            lhs.disjunctive == rhs.disjunctive
    }
}

extension SearchAutomaticFacetFilter: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.facet.hashValue)
        hasher.combine(self.score?.hashValue)
        hasher.combine(self.disjunctive?.hashValue)
    }
}
