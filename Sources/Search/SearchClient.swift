// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
// https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import Foundation
#if canImport(Core)
    import Core
#endif

open class SearchClient {
    private var configuration: SearchClientConfiguration
    private var transporter: Transporter

    var appID: String {
        self.configuration.appID
    }

    public init(configuration: SearchClientConfiguration, transporter: Transporter) {
        self.configuration = configuration
        self.transporter = transporter
    }

    public convenience init(configuration: SearchClientConfiguration) {
        self.init(configuration: configuration, transporter: Transporter(configuration: configuration))
    }

    public convenience init(appID: String, apiKey: String) throws {
        try self.init(configuration: SearchClientConfiguration(appID: appID, apiKey: apiKey))
    }

    open func setClientApiKey(apiKey: String) {
        self.configuration.apiKey = apiKey
        self.transporter.setClientApiKey(apiKey: apiKey)
    }

    /// - parameter apiKey: (body)
    /// - returns: AddApiKeyResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func addApiKey(apiKey: ApiKey, requestOptions: RequestOptions? = nil) async throws -> AddApiKeyResponse {
        let response: Response<AddApiKeyResponse> = try await addApiKeyWithHTTPInfo(
            apiKey: apiKey,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Creates a new API key with specific permissions and restrictions.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter apiKey: (body)
    // - returns: RequestBuilder<AddApiKeyResponse>

    open func addApiKeyWithHTTPInfo(
        apiKey: ApiKey,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AddApiKeyResponse> {
        let resourcePath = "/1/keys"
        let body = apiKey
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter objectID: (path) Unique record identifier.
    /// - parameter body: (body) The record. A schemaless object with attributes that are useful in the context of
    /// search and discovery.
    /// - returns: UpdatedAtWithObjectIdResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func addOrUpdateObject(
        indexName: String,
        objectID: String,
        body: Codable,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtWithObjectIdResponse {
        let response: Response<UpdatedAtWithObjectIdResponse> = try await addOrUpdateObjectWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // If a record with the specified object ID exists, the existing record is replaced. Otherwise, a new record is
    // added to the index.  If you want to use auto-generated object IDs, use the [`saveObject`
    // operation](https://www.algolia.com/doc/rest-api/search/save-object). To update _some_ attributes of an existing
    // record, use the [`partial` operation](https://www.algolia.com/doc/rest-api/search/partial-update-object) instead.
    // To add, update, or replace multiple records, use the [`batch`
    // operation](https://www.algolia.com/doc/rest-api/search/batch).
    // Required API Key ACLs:
    //  - addObject
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter objectID: (path) Unique record identifier.
    //
    // - parameter body: (body) The record. A schemaless object with attributes that are useful in the context of search
    // and discovery.
    // - returns: RequestBuilder<UpdatedAtWithObjectIdResponse>

    open func addOrUpdateObjectWithHTTPInfo(
        indexName: String,
        objectID: String,
        body: Codable,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtWithObjectIdResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "addOrUpdateObject")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "addOrUpdateObject")
        }

        var resourcePath = "/1/indexes/{indexName}/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter source: (body) Source to add.
    /// - returns: CreatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func appendSource(
        source: SearchSource,
        requestOptions: RequestOptions? = nil
    ) async throws -> CreatedAtResponse {
        let response: Response<CreatedAtResponse> = try await appendSourceWithHTTPInfo(
            source: source,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Adds a source to the list of allowed sources.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter source: (body) Source to add.
    // - returns: RequestBuilder<CreatedAtResponse>

    open func appendSourceWithHTTPInfo(
        source: SearchSource,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<CreatedAtResponse> {
        let resourcePath = "/1/security/sources/append"
        let body = source
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter xAlgoliaUserID: (header) Unique identifier of the user who makes the search request.
    /// - parameter assignUserIdParams: (body)
    /// - returns: CreatedAtResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func assignUserId(
        xAlgoliaUserID: String,
        assignUserIdParams: AssignUserIdParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> CreatedAtResponse {
        let response: Response<CreatedAtResponse> = try await assignUserIdWithHTTPInfo(
            xAlgoliaUserID: xAlgoliaUserID,
            assignUserIdParams: assignUserIdParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Assigns or moves a user ID to a cluster.  The time it takes to move a user is proportional to the amount of data
    /// linked to the user ID.
    /// Required API Key ACLs:
    ///  - admin
    ///
    /// - parameter xAlgoliaUserID: (header) Unique identifier of the user who makes the search request.
    ///
    /// - parameter assignUserIdParams: (body)
    /// - returns: RequestBuilder<CreatedAtResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func assignUserIdWithHTTPInfo(
        xAlgoliaUserID: String,
        assignUserIdParams: AssignUserIdParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<CreatedAtResponse> {
        let resourcePath = "/1/clusters/mapping"
        let body = assignUserIdParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = [
            "X-Algolia-User-ID": xAlgoliaUserID.encodeToJSON(),
        ]

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter batchWriteParams: (body)
    /// - returns: BatchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func batch(
        indexName: String,
        batchWriteParams: SearchBatchWriteParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> BatchResponse {
        let response: Response<BatchResponse> = try await batchWithHTTPInfo(
            indexName: indexName,
            batchWriteParams: batchWriteParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Adds, updates, or deletes records in one index with a single API request.  Batching index updates reduces latency
    // and increases data integrity.  - Actions are applied in the order they're specified. - Actions are equivalent to
    // the individual API requests of the same name.  This operation is subject to [indexing rate
    // limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    //
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter batchWriteParams: (body)
    // - returns: RequestBuilder<BatchResponse>

    open func batchWithHTTPInfo(
        indexName: String,
        batchWriteParams: SearchBatchWriteParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<BatchResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "batch")
        }

        var resourcePath = "/1/indexes/{indexName}/batch"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = batchWriteParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter xAlgoliaUserID: (header) Unique identifier of the user who makes the search request.
    /// - parameter batchAssignUserIdsParams: (body)
    /// - returns: CreatedAtResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func batchAssignUserIds(
        xAlgoliaUserID: String,
        batchAssignUserIdsParams: BatchAssignUserIdsParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> CreatedAtResponse {
        let response: Response<CreatedAtResponse> = try await batchAssignUserIdsWithHTTPInfo(
            xAlgoliaUserID: xAlgoliaUserID,
            batchAssignUserIdsParams: batchAssignUserIdsParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Assigns multiple user IDs to a cluster.  **You can't move users with this operation**.
    /// Required API Key ACLs:
    ///  - admin
    ///
    /// - parameter xAlgoliaUserID: (header) Unique identifier of the user who makes the search request.
    ///
    /// - parameter batchAssignUserIdsParams: (body)
    /// - returns: RequestBuilder<CreatedAtResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func batchAssignUserIdsWithHTTPInfo(
        xAlgoliaUserID: String,
        batchAssignUserIdsParams: BatchAssignUserIdsParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<CreatedAtResponse> {
        let resourcePath = "/1/clusters/mapping/batch"
        let body = batchAssignUserIdsParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = [
            "X-Algolia-User-ID": xAlgoliaUserID.encodeToJSON(),
        ]

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter dictionaryName: (path) Dictionary type in which to search.
    /// - parameter batchDictionaryEntriesParams: (body)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func batchDictionaryEntries(
        dictionaryName: DictionaryType,
        batchDictionaryEntriesParams: BatchDictionaryEntriesParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await batchDictionaryEntriesWithHTTPInfo(
            dictionaryName: dictionaryName,
            batchDictionaryEntriesParams: batchDictionaryEntriesParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Adds or deletes multiple entries from your plurals, segmentation, or stop word dictionaries.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter dictionaryName: (path) Dictionary type in which to search.
    //
    // - parameter batchDictionaryEntriesParams: (body)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func batchDictionaryEntriesWithHTTPInfo(
        dictionaryName: DictionaryType,
        batchDictionaryEntriesParams: BatchDictionaryEntriesParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        var resourcePath = "/1/dictionaries/{dictionaryName}/batch"
        let dictionaryNamePreEscape = "\(APIHelper.mapValueToPathItem(dictionaryName))"
        let dictionaryNamePostEscape = dictionaryNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{dictionaryName}",
            with: dictionaryNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = batchDictionaryEntriesParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter browseParams: (body)  (optional)
    /// - returns: BrowseResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func browse<T: Codable>(
        indexName: String,
        browseParams: BrowseParams? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> BrowseResponse<T> {
        let response: Response<BrowseResponse<T>> = try await browseWithHTTPInfo(
            indexName: indexName,
            browseParams: browseParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves records from an index, up to 1,000 per request.  While searching retrieves _hits_ (records augmented
    // with attributes for highlighting and ranking details), browsing _just_ returns matching records. This can be
    // useful if you want to export your indices.  - The Analytics API doesn't collect data when using `browse`. -
    // Records are ranked by attributes and custom ranking. - There's no ranking for: typo-tolerance, number of matched
    // words, proximity, geo distance.  Browse requests automatically apply these settings:  - `advancedSyntax`: `false`
    // - `attributesToHighlight`: `[]` - `attributesToSnippet`: `[]` - `distinct`: `false` - `enablePersonalization`:
    // `false` - `enableRules`: `false` - `facets`: `[]` - `getRankingInfo`: `false` - `ignorePlurals`: `false` -
    // `optionalFilters`: `[]` - `typoTolerance`: `true` or `false` (`min` and `strict` evaluate to `true`)  If you send these parameters with your browse requests, they'll be ignored.
    // Required API Key ACLs:
    //  - browse
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter browseParams: (body)  (optional)
    // - returns: RequestBuilder<BrowseResponse>

    open func browseWithHTTPInfo<T: Codable>(
        indexName: String,
        browseParams: BrowseParams? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<BrowseResponse<T>> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "browse")
        }

        var resourcePath = "/1/indexes/{indexName}/browse"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = browseParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func clearObjects(indexName: String, requestOptions: RequestOptions? = nil) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await clearObjectsWithHTTPInfo(
            indexName: indexName,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes only the records from an index while keeping settings, synonyms, and rules. This operation is
    // resource-intensive and subject to [indexing rate
    // limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    // Required API Key ACLs:
    //  - deleteIndex
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func clearObjectsWithHTTPInfo(
        indexName: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "clearObjects")
        }

        var resourcePath = "/1/indexes/{indexName}/clear"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func clearRules(
        indexName: String,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await clearRulesWithHTTPInfo(
            indexName: indexName,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes all rules from the index.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func clearRulesWithHTTPInfo(
        indexName: String,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "clearRules")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/clear"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func clearSynonyms(
        indexName: String,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await clearSynonymsWithHTTPInfo(
            indexName: indexName,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes all synonyms from the index.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func clearSynonymsWithHTTPInfo(
        indexName: String,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "clearSynonyms")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/clear"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customDelete(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customDeleteWithHTTPInfo(
            path: path,
            parameters: parameters,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method lets you send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customDeleteWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customDelete")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customGet(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customGetWithHTTPInfo(
            path: path,
            parameters: parameters,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method lets you send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customGetWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customGet")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - parameter body: (body) Parameters to send with the custom request. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customPost(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customPostWithHTTPInfo(
            path: path,
            parameters: parameters,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method lets you send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    //
    // - parameter body: (body) Parameters to send with the custom request. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customPostWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customPost")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - parameter body: (body) Parameters to send with the custom request. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customPut(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customPutWithHTTPInfo(
            path: path,
            parameters: parameters,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method lets you send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, for example `1/newFeature`.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    //
    // - parameter body: (body) Parameters to send with the custom request. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customPutWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customPut")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter key: (path) API key.
    /// - returns: DeleteApiKeyResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteApiKey(key: String, requestOptions: RequestOptions? = nil) async throws -> DeleteApiKeyResponse {
        let response: Response<DeleteApiKeyResponse> = try await deleteApiKeyWithHTTPInfo(
            key: key,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes the API key.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter key: (path) API key.
    // - returns: RequestBuilder<DeleteApiKeyResponse>

    open func deleteApiKeyWithHTTPInfo(
        key: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteApiKeyResponse> {
        guard !key.isEmpty else {
            throw AlgoliaError.invalidArgument("key", "deleteApiKey")
        }

        var resourcePath = "/1/keys/{key}"
        let keyPreEscape = "\(APIHelper.mapValueToPathItem(key))"
        let keyPostEscape = keyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{key}",
            with: keyPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter deleteByParams: (body)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteBy(
        indexName: String,
        deleteByParams: DeleteByParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await deleteByWithHTTPInfo(
            indexName: indexName,
            deleteByParams: deleteByParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This operation doesn't accept empty filters.  This operation is resource-intensive. You should only use it if you
    // can't get the object IDs of the records you want to delete. It's more efficient to get a list of object IDs with
    // the [`browse` operation](https://www.algolia.com/doc/rest-api/search/browse), and then delete the records using
    // the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).  This operation is subject to
    // [indexing rate
    // limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    // Required API Key ACLs:
    //  - deleteIndex
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter deleteByParams: (body)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func deleteByWithHTTPInfo(
        indexName: String,
        deleteByParams: DeleteByParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "deleteBy")
        }

        var resourcePath = "/1/indexes/{indexName}/deleteByQuery"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = deleteByParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - returns: SearchDeletedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteIndex(
        indexName: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchDeletedAtResponse {
        let response: Response<SearchDeletedAtResponse> = try await deleteIndexWithHTTPInfo(
            indexName: indexName,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes an index and all its settings.  - Deleting an index doesn't delete its analytics data. - If you try to
    // delete a non-existing index, the operation is ignored without warning. - If the index you want to delete has
    // replica indices, the replicas become independent indices. - If the index you want to delete is a replica index,
    // you must first unlink it from its primary index before you can delete it.   For more information, see [Delete
    // replica
    // indices](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/how-to/deleting-replicas).
    // Required API Key ACLs:
    //  - deleteIndex
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    // - returns: RequestBuilder<SearchDeletedAtResponse>

    open func deleteIndexWithHTTPInfo(
        indexName: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchDeletedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "deleteIndex")
        }

        var resourcePath = "/1/indexes/{indexName}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter objectID: (path) Unique record identifier.
    /// - returns: SearchDeletedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteObject(
        indexName: String,
        objectID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchDeletedAtResponse {
        let response: Response<SearchDeletedAtResponse> = try await deleteObjectWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a record by its object ID.  To delete more than one record, use the [`batch`
    // operation](https://www.algolia.com/doc/rest-api/search/batch). To delete records matching a query, use the
    // [`deleteBy` operation](https://www.algolia.com/doc/rest-api/search/delete-by).
    // Required API Key ACLs:
    //  - deleteObject
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter objectID: (path) Unique record identifier.
    // - returns: RequestBuilder<SearchDeletedAtResponse>

    open func deleteObjectWithHTTPInfo(
        indexName: String,
        objectID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchDeletedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "deleteObject")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "deleteObject")
        }

        var resourcePath = "/1/indexes/{indexName}/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter objectID: (path) Unique identifier of a rule object.
    /// - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteRule(
        indexName: String,
        objectID: String,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await deleteRuleWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a rule by its ID. To find the object ID for rules, use the [`search`
    // operation](https://www.algolia.com/doc/rest-api/search/search-rules).
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter objectID: (path) Unique identifier of a rule object.
    //
    // - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func deleteRuleWithHTTPInfo(
        indexName: String,
        objectID: String,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "deleteRule")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "deleteRule")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter source: (path) IP address range of the source.
    /// - returns: DeleteSourceResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteSource(source: String, requestOptions: RequestOptions? = nil) async throws -> DeleteSourceResponse {
        let response: Response<DeleteSourceResponse> = try await deleteSourceWithHTTPInfo(
            source: source,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a source from the list of allowed sources.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter source: (path) IP address range of the source.
    // - returns: RequestBuilder<DeleteSourceResponse>

    open func deleteSourceWithHTTPInfo(
        source: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteSourceResponse> {
        guard !source.isEmpty else {
            throw AlgoliaError.invalidArgument("source", "deleteSource")
        }

        var resourcePath = "/1/security/sources/{source}"
        let sourcePreEscape = "\(APIHelper.mapValueToPathItem(source))"
        let sourcePostEscape = sourcePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{source}",
            with: sourcePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter objectID: (path) Unique identifier of a synonym object.
    /// - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    /// - returns: SearchDeletedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteSynonym(
        indexName: String,
        objectID: String,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchDeletedAtResponse {
        let response: Response<SearchDeletedAtResponse> = try await deleteSynonymWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a synonym by its ID. To find the object IDs of your synonyms, use the [`search`
    // operation](https://www.algolia.com/doc/rest-api/search/search-synonyms).
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter objectID: (path) Unique identifier of a synonym object.
    //
    // - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    // - returns: RequestBuilder<SearchDeletedAtResponse>

    open func deleteSynonymWithHTTPInfo(
        indexName: String,
        objectID: String,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchDeletedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "deleteSynonym")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "deleteSynonym")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter key: (path) API key.
    /// - returns: GetApiKeyResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getApiKey(key: String, requestOptions: RequestOptions? = nil) async throws -> GetApiKeyResponse {
        let response: Response<GetApiKeyResponse> = try await getApiKeyWithHTTPInfo(
            key: key,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Gets the permissions and restrictions of an API key.  When authenticating with the admin API key, you can request
    // information for any of your application's keys. When authenticating with other API keys, you can only retrieve
    // information for that key, with the description replaced by `<redacted>`.
    //
    //
    // - parameter key: (path) API key.
    // - returns: RequestBuilder<GetApiKeyResponse>

    open func getApiKeyWithHTTPInfo(
        key: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<GetApiKeyResponse> {
        guard !key.isEmpty else {
            throw AlgoliaError.invalidArgument("key", "getApiKey")
        }

        var resourcePath = "/1/keys/{key}"
        let keyPreEscape = "\(APIHelper.mapValueToPathItem(key))"
        let keyPostEscape = keyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{key}",
            with: keyPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique task identifier.
    /// - returns: GetTaskResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getAppTask(taskID: Int64, requestOptions: RequestOptions? = nil) async throws -> GetTaskResponse {
        let response: Response<GetTaskResponse> = try await getAppTaskWithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Checks the status of a given application task.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter taskID: (path) Unique task identifier.
    // - returns: RequestBuilder<GetTaskResponse>

    open func getAppTaskWithHTTPInfo(
        taskID: Int64,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<GetTaskResponse> {
        var resourcePath = "/1/task/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - returns: [String: SearchLanguages]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getDictionaryLanguages(requestOptions: RequestOptions? = nil) async throws -> [String: SearchLanguages] {
        let response: Response<[String: SearchLanguages]> =
            try await getDictionaryLanguagesWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Lists supported languages with their supported dictionary types and number of custom entries.
    // Required API Key ACLs:
    //  - settings
    //     - returns: RequestBuilder<[String: SearchLanguages]>

    open func getDictionaryLanguagesWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<[String: SearchLanguages]> {
        let resourcePath = "/1/dictionaries/*/languages"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - returns: GetDictionarySettingsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getDictionarySettings(requestOptions: RequestOptions? = nil) async throws
    -> GetDictionarySettingsResponse {
        let response: Response<GetDictionarySettingsResponse> =
            try await getDictionarySettingsWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves the languages for which standard dictionary entries are turned off.
    // Required API Key ACLs:
    //  - settings
    //     - returns: RequestBuilder<GetDictionarySettingsResponse>

    open func getDictionarySettingsWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<GetDictionarySettingsResponse> {
        let resourcePath = "/1/dictionaries/*/settings"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter offset: (query) First log entry to retrieve. The most recent entries are listed first. (optional,
    /// default to 0)
    /// - parameter length: (query) Maximum number of entries to retrieve. (optional, default to 10)
    /// - parameter indexName: (query) Index for which to retrieve log entries. By default, log entries are retrieved
    /// for all indices.  (optional)
    /// - parameter type: (query) Type of log entries to retrieve. By default, all log entries are retrieved. 
    /// (optional)
    /// - returns: GetLogsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getLogs(
        offset: Int? = nil,
        length: Int? = nil,
        indexName: String? = nil,
        type: LogType? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> GetLogsResponse {
        let response: Response<GetLogsResponse> = try await getLogsWithHTTPInfo(
            offset: offset,
            length: length,
            indexName: indexName,
            type: type,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // The request must be authenticated by an API key with the [`logs`
    // ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).  - Logs are held for the
    // last
    // seven days. - Up to 1,000 API requests per server are logged. - This request counts towards your [operations
    // quota](https://support.algolia.com/hc/articles/17245378392977-How-does-Algolia-count-records-and-operations) but
    // doesn't appear in the logs itself.
    // Required API Key ACLs:
    //  - logs
    //
    // - parameter offset: (query) First log entry to retrieve. The most recent entries are listed first. (optional,
    // default to 0)
    //
    // - parameter length: (query) Maximum number of entries to retrieve. (optional, default to 10)
    //
    // - parameter indexName: (query) Index for which to retrieve log entries. By default, log entries are retrieved for
    // all indices.  (optional)
    //
    // - parameter type: (query) Type of log entries to retrieve. By default, all log entries are retrieved.  (optional)
    // - returns: RequestBuilder<GetLogsResponse>

    open func getLogsWithHTTPInfo(
        offset: Int? = nil,
        length: Int? = nil,
        indexName: String? = nil,
        type: LogType? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<GetLogsResponse> {
        let resourcePath = "/1/logs"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "offset": offset?.encodeToJSON(),
            "length": length?.encodeToJSON(),
            "indexName": indexName?.encodeToJSON(),
            "type": type?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter objectID: (path) Unique record identifier.
    /// - parameter attributesToRetrieve: (query) Attributes to include with the records in the response. This is useful
    /// to reduce the size of the API response. By default, all retrievable attributes are returned.  `objectID` is
    /// always retrieved.  Attributes included in `unretrievableAttributes` won't be retrieved unless the request is
    /// authenticated with the admin API key.  (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getObject(
        indexName: String,
        objectID: String,
        attributesToRetrieve: [String]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await getObjectWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            attributesToRetrieve: attributesToRetrieve,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves one record by its object ID.  To retrieve more than one record, use the [`objects`
    // operation](https://www.algolia.com/doc/rest-api/search/get-objects).
    // Required API Key ACLs:
    //  - search
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter objectID: (path) Unique record identifier.
    //
    // - parameter attributesToRetrieve: (query) Attributes to include with the records in the response. This is useful
    // to reduce the size of the API response. By default, all retrievable attributes are returned.  `objectID` is
    // always
    // retrieved.  Attributes included in `unretrievableAttributes` won't be retrieved unless the request is
    // authenticated with the admin API key.  (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func getObjectWithHTTPInfo(
        indexName: String,
        objectID: String,
        attributesToRetrieve: [String]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "getObject")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "getObject")
        }

        var resourcePath = "/1/indexes/{indexName}/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "attributesToRetrieve": attributesToRetrieve?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter getObjectsParams: (body) Request object.
    /// - returns: GetObjectsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getObjects<T: Codable>(
        getObjectsParams: GetObjectsParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> GetObjectsResponse<T> {
        let response: Response<GetObjectsResponse<T>> = try await getObjectsWithHTTPInfo(
            getObjectsParams: getObjectsParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves one or more records, potentially from different indices.  Records are returned in the same order as the
    // requests.
    // Required API Key ACLs:
    //  - search
    //
    // - parameter getObjectsParams: (body) Request object.
    // - returns: RequestBuilder<GetObjectsResponse>

    open func getObjectsWithHTTPInfo<T: Codable>(
        getObjectsParams: GetObjectsParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<GetObjectsResponse<T>> {
        let resourcePath = "/1/indexes/*/objects"
        let body = getObjectsParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter objectID: (path) Unique identifier of a rule object.
    /// - returns: Rule
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getRule(indexName: String, objectID: String, requestOptions: RequestOptions? = nil) async throws -> Rule {
        let response: Response<Rule> = try await getRuleWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a rule by its ID. To find the object ID of rules, use the [`search`
    // operation](https://www.algolia.com/doc/rest-api/search/search-rules).
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter objectID: (path) Unique identifier of a rule object.
    // - returns: RequestBuilder<Rule>

    open func getRuleWithHTTPInfo(
        indexName: String,
        objectID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Rule> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "getRule")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "getRule")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter getVersion: (query) When set to 2, the endpoint will not include `synonyms` in the response. This
    /// parameter is here for backward compatibility. (optional, default to 1)
    /// - returns: SettingsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getSettings(
        indexName: String,
        getVersion: Int? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SettingsResponse {
        let response: Response<SettingsResponse> = try await getSettingsWithHTTPInfo(
            indexName: indexName,
            getVersion: getVersion,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves an object with non-null index settings.
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter getVersion: (query) When set to 2, the endpoint will not include `synonyms` in the response. This
    // parameter is here for backward compatibility. (optional, default to 1)
    // - returns: RequestBuilder<SettingsResponse>

    open func getSettingsWithHTTPInfo(
        indexName: String,
        getVersion: Int? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SettingsResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "getSettings")
        }

        var resourcePath = "/1/indexes/{indexName}/settings"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "getVersion": getVersion?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - returns: [SearchSource]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getSources(requestOptions: RequestOptions? = nil) async throws -> [SearchSource] {
        let response: Response<[SearchSource]> = try await getSourcesWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves all allowed IP addresses with access to your application.
    // Required API Key ACLs:
    //  - admin
    //     - returns: RequestBuilder<[SearchSource]>

    open func getSourcesWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<[SearchSource]> {
        let resourcePath = "/1/security/sources"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter objectID: (path) Unique identifier of a synonym object.
    /// - returns: SynonymHit
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getSynonym(
        indexName: String,
        objectID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> SynonymHit {
        let response: Response<SynonymHit> = try await getSynonymWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a synonym by its ID. To find the object IDs for your synonyms, use the [`search`
    // operation](https://www.algolia.com/doc/rest-api/search/search-synonyms).
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter objectID: (path) Unique identifier of a synonym object.
    // - returns: RequestBuilder<SynonymHit>

    open func getSynonymWithHTTPInfo(
        indexName: String,
        objectID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SynonymHit> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "getSynonym")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "getSynonym")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter taskID: (path) Unique task identifier.
    /// - returns: GetTaskResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getTask(
        indexName: String,
        taskID: Int64,
        requestOptions: RequestOptions? = nil
    ) async throws -> GetTaskResponse {
        let response: Response<GetTaskResponse> = try await getTaskWithHTTPInfo(
            indexName: indexName,
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Checks the status of a given task.  Indexing tasks are asynchronous. When you add, update, or delete records or
    // indices, a task is created on a queue and completed depending on the load on the server.  The indexing tasks'
    // responses include a task ID that you can use to check the status.
    // Required API Key ACLs:
    //  - addObject
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter taskID: (path) Unique task identifier.
    // - returns: RequestBuilder<GetTaskResponse>

    open func getTaskWithHTTPInfo(
        indexName: String,
        taskID: Int64,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<GetTaskResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "getTask")
        }

        var resourcePath = "/1/indexes/{indexName}/task/{taskID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - returns: GetTopUserIdsResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getTopUserIds(requestOptions: RequestOptions? = nil) async throws -> GetTopUserIdsResponse {
        let response: Response<GetTopUserIdsResponse> =
            try await getTopUserIdsWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Get the IDs of the 10 users with the highest number of records per cluster.  Since it can take a few seconds to
    /// get the data from the different clusters, the response isn't real-time.
    /// Required API Key ACLs:
    ///  - admin
    ///     - returns: RequestBuilder<GetTopUserIdsResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func getTopUserIdsWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<GetTopUserIdsResponse> {
        let resourcePath = "/1/clusters/mapping/top"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter userID: (path) Unique identifier of the user who makes the search request.
    /// - returns: UserId
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getUserId(userID: String, requestOptions: RequestOptions? = nil) async throws -> UserId {
        let response: Response<UserId> = try await getUserIdWithHTTPInfo(userID: userID, requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Returns the user ID data stored in the mapping.  Since it can take a few seconds to get the data from the
    /// different clusters, the response isn't real-time.
    /// Required API Key ACLs:
    ///  - admin
    ///
    /// - parameter userID: (path) Unique identifier of the user who makes the search request.
    /// - returns: RequestBuilder<UserId>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func getUserIdWithHTTPInfo(
        userID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UserId> {
        guard !userID.isEmpty else {
            throw AlgoliaError.invalidArgument("userID", "getUserId")
        }

        var resourcePath = "/1/clusters/mapping/{userID}"
        let userIDPreEscape = "\(APIHelper.mapValueToPathItem(userID))"
        let userIDPostEscape = userIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{userID}",
            with: userIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter getClusters: (query) Whether to include the cluster's pending mapping state in the response.
    /// (optional)
    /// - returns: HasPendingMappingsResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func hasPendingMappings(
        getClusters: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> HasPendingMappingsResponse {
        let response: Response<HasPendingMappingsResponse> = try await hasPendingMappingsWithHTTPInfo(
            getClusters: getClusters,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// To determine when the time-consuming process of creating a large batch of users or migrating users from one
    /// cluster to another is complete, this operation retrieves the status of the process.
    /// Required API Key ACLs:
    ///  - admin
    ///
    /// - parameter getClusters: (query) Whether to include the cluster's pending mapping state in the response.
    /// (optional)
    /// - returns: RequestBuilder<HasPendingMappingsResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func hasPendingMappingsWithHTTPInfo(
        getClusters: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<HasPendingMappingsResponse> {
        let resourcePath = "/1/clusters/mapping/pending"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "getClusters": getClusters?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - returns: ListApiKeysResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listApiKeys(requestOptions: RequestOptions? = nil) async throws -> ListApiKeysResponse {
        let response: Response<ListApiKeysResponse> = try await listApiKeysWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Lists all API keys associated with your Algolia application, including their permissions and restrictions.
    // Required API Key ACLs:
    //  - admin
    //     - returns: RequestBuilder<ListApiKeysResponse>

    open func listApiKeysWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<ListApiKeysResponse> {
        let resourcePath = "/1/keys"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - returns: ListClustersResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listClusters(requestOptions: RequestOptions? = nil) async throws -> ListClustersResponse {
        let response: Response<ListClustersResponse> =
            try await listClustersWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Lists the available clusters in a multi-cluster setup.
    /// Required API Key ACLs:
    ///  - admin
    ///     - returns: RequestBuilder<ListClustersResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func listClustersWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<ListClustersResponse> {
        let resourcePath = "/1/clusters"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter page: (query) Requested page of the API response. If `null`, the API response is not paginated. 
    /// (optional)
    /// - parameter hitsPerPage: (query) Number of hits per page. (optional, default to 100)
    /// - returns: ListIndicesResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listIndices(
        page: Int? = nil,
        hitsPerPage: Int? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListIndicesResponse {
        let response: Response<ListIndicesResponse> = try await listIndicesWithHTTPInfo(
            page: page,
            hitsPerPage: hitsPerPage,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Lists all indices in the current Algolia application.  The request follows any index restrictions of the API key
    // you use to make the request.
    // Required API Key ACLs:
    //  - listIndexes
    //
    // - parameter page: (query) Requested page of the API response. If `null`, the API response is not paginated. 
    // (optional)
    //
    // - parameter hitsPerPage: (query) Number of hits per page. (optional, default to 100)
    // - returns: RequestBuilder<ListIndicesResponse>

    open func listIndicesWithHTTPInfo(
        page: Int? = nil,
        hitsPerPage: Int? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListIndicesResponse> {
        let resourcePath = "/1/indexes"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "page": page?.encodeToJSON(),
            "hitsPerPage": hitsPerPage?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter page: (query) Requested page of the API response. If `null`, the API response is not paginated. 
    /// (optional)
    /// - parameter hitsPerPage: (query) Number of hits per page. (optional, default to 100)
    /// - returns: ListUserIdsResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listUserIds(
        page: Int? = nil,
        hitsPerPage: Int? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListUserIdsResponse {
        let response: Response<ListUserIdsResponse> = try await listUserIdsWithHTTPInfo(
            page: page,
            hitsPerPage: hitsPerPage,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Lists the userIDs assigned to a multi-cluster application.  Since it can take a few seconds to get the data from
    /// the different clusters, the response isn't real-time.
    /// Required API Key ACLs:
    ///  - admin
    ///
    /// - parameter page: (query) Requested page of the API response. If `null`, the API response is not paginated. 
    /// (optional)
    ///
    /// - parameter hitsPerPage: (query) Number of hits per page. (optional, default to 100)
    /// - returns: RequestBuilder<ListUserIdsResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func listUserIdsWithHTTPInfo(
        page: Int? = nil,
        hitsPerPage: Int? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListUserIdsResponse> {
        let resourcePath = "/1/clusters/mapping"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "page": page?.encodeToJSON(),
            "hitsPerPage": hitsPerPage?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter batchParams: (body)
    /// - returns: MultipleBatchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func multipleBatch(
        batchParams: BatchParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> MultipleBatchResponse {
        let response: Response<MultipleBatchResponse> = try await multipleBatchWithHTTPInfo(
            batchParams: batchParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Adds, updates, or deletes records in multiple indices with a single API request.  - Actions are applied in the
    // order they are specified. - Actions are equivalent to the individual API requests of the same name.  This
    // operation is subject to [indexing rate
    // limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    //
    //
    // - parameter batchParams: (body)
    // - returns: RequestBuilder<MultipleBatchResponse>

    open func multipleBatchWithHTTPInfo(
        batchParams: BatchParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<MultipleBatchResponse> {
        let resourcePath = "/1/indexes/*/batch"
        let body = batchParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter operationIndexParams: (body)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func operationIndex(
        indexName: String,
        operationIndexParams: OperationIndexParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await operationIndexWithHTTPInfo(
            indexName: indexName,
            operationIndexParams: operationIndexParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Copies or moves (renames) an index within the same Algolia application.  - Existing destination indices are
    // overwritten, except for their analytics data. - If the destination index doesn't exist yet, it'll be created. -
    // This operation is resource-intensive.  **Copy**  - Copying a source index that doesn't exist creates a new index
    // with 0 records and default settings. - The API keys of the source index are merged with the existing keys in the
    // destination index. - You can't copy the `enableReRanking`, `mode`, and `replicas` settings. - You can't copy to a
    // destination index that already has replicas. - Be aware of the [size
    // limits](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits).
    // -
    // Related guide: [Copy indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/copy-indices)
    // **Move**  - Moving a source index that doesn't exist is ignored without returning an error. - When moving an
    // index, the analytics data keeps its original name, and a new set of analytics data is started for the new name.  
    // To access the original analytics in the dashboard, create an index with the original name. - If the destination
    // index has replicas, moving will overwrite the existing index and copy the data to the replica indices. - Related
    // guide: [Move indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/move-indices).  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    // Required API Key ACLs:
    //  - addObject
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter operationIndexParams: (body)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func operationIndexWithHTTPInfo(
        indexName: String,
        operationIndexParams: OperationIndexParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "operationIndex")
        }

        var resourcePath = "/1/indexes/{indexName}/operation"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = operationIndexParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter objectID: (path) Unique record identifier.
    /// - parameter attributesToUpdate: (body) Attributes with their values.
    /// - parameter createIfNotExists: (query) Whether to create a new record if it doesn't exist. (optional, default to
    /// true)
    /// - returns: UpdatedAtWithObjectIdResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func partialUpdateObject(
        indexName: String,
        objectID: String,
        attributesToUpdate: Codable,
        createIfNotExists: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtWithObjectIdResponse {
        let response: Response<UpdatedAtWithObjectIdResponse> = try await partialUpdateObjectWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            attributesToUpdate: attributesToUpdate,
            createIfNotExists: createIfNotExists,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Adds new attributes to a record, or updates existing ones.  - If a record with the specified object ID doesn't
    // exist,   a new record is added to the index **if** `createIfNotExists` is true. - If the index doesn't exist yet,
    // this method creates a new index. - You can use any first-level attribute but not nested attributes.   If you
    // specify a nested attribute, this operation replaces its first-level ancestor.  To update an attribute without
    // pushing the entire record, you can use these built-in operations. These operations can be helpful if you don't
    // have access to your initial data.  - Increment: increment a numeric attribute - Decrement: decrement a numeric
    // attribute - Add: append a number or string element to an array attribute - Remove: remove all matching number or
    // string elements from an array attribute made of numbers or strings - AddUnique: add a number or string element to
    // an array attribute made of numbers or strings only if it's not already present - IncrementFrom: increment a
    // numeric integer attribute only if the provided value matches the current value, and otherwise ignore the whole
    // object update. For example, if you pass an IncrementFrom value of 2 for the version attribute, but the current
    // value of the attribute is 1, the engine ignores the update. If the object doesn't exist, the engine only creates
    // it if you pass an IncrementFrom value of 0. - IncrementSet: increment a numeric integer attribute only if the
    // provided value is greater than the current value, and otherwise ignore the whole object update. For example, if
    // you pass an IncrementSet value of 2 for the version attribute, and the current value of the attribute is 1, the
    // engine updates the object. If the object doesn't exist yet, the engine only creates it if you pass an
    // IncrementSet
    // value greater than 0.  You can specify an operation by providing an object with the attribute to update as the
    // key
    // and its value being an object with the following properties:  - _operation: the operation to apply on the
    // attribute - value: the right-hand side argument to the operation, for example, increment or decrement step, value
    // to add or remove.  When updating multiple attributes or using multiple operations targeting the same record, you
    // should use a single partial update for faster processing.  This operation is subject to [indexing rate
    // limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    // Required API Key ACLs:
    //  - addObject
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter objectID: (path) Unique record identifier.
    //
    // - parameter attributesToUpdate: (body) Attributes with their values.
    //
    // - parameter createIfNotExists: (query) Whether to create a new record if it doesn't exist. (optional, default to
    // true)
    // - returns: RequestBuilder<UpdatedAtWithObjectIdResponse>

    open func partialUpdateObjectWithHTTPInfo(
        indexName: String,
        objectID: String,
        attributesToUpdate: Codable,
        createIfNotExists: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtWithObjectIdResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "partialUpdateObject")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "partialUpdateObject")
        }

        var resourcePath = "/1/indexes/{indexName}/{objectID}/partial"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = attributesToUpdate
        let queryParameters: [String: Any?] = [
            "createIfNotExists": createIfNotExists?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter userID: (path) Unique identifier of the user who makes the search request.
    /// - returns: RemoveUserIdResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func removeUserId(userID: String, requestOptions: RequestOptions? = nil) async throws -> RemoveUserIdResponse {
        let response: Response<RemoveUserIdResponse> = try await removeUserIdWithHTTPInfo(
            userID: userID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Deletes a user ID and its associated data from the clusters.
    /// Required API Key ACLs:
    ///  - admin
    ///
    /// - parameter userID: (path) Unique identifier of the user who makes the search request.
    /// - returns: RequestBuilder<RemoveUserIdResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func removeUserIdWithHTTPInfo(
        userID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<RemoveUserIdResponse> {
        guard !userID.isEmpty else {
            throw AlgoliaError.invalidArgument("userID", "removeUserId")
        }

        var resourcePath = "/1/clusters/mapping/{userID}"
        let userIDPreEscape = "\(APIHelper.mapValueToPathItem(userID))"
        let userIDPostEscape = userIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{userID}",
            with: userIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter source: (body) Allowed sources.
    /// - returns: ReplaceSourceResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func replaceSources(
        source: [SearchSource],
        requestOptions: RequestOptions? = nil
    ) async throws -> ReplaceSourceResponse {
        let response: Response<ReplaceSourceResponse> = try await replaceSourcesWithHTTPInfo(
            source: source,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Replaces the list of allowed sources.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter source: (body) Allowed sources.
    // - returns: RequestBuilder<ReplaceSourceResponse>

    open func replaceSourcesWithHTTPInfo(
        source: [SearchSource],
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ReplaceSourceResponse> {
        let resourcePath = "/1/security/sources"
        let body = source
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter key: (path) API key.
    /// - returns: AddApiKeyResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func restoreApiKey(key: String, requestOptions: RequestOptions? = nil) async throws -> AddApiKeyResponse {
        let response: Response<AddApiKeyResponse> = try await restoreApiKeyWithHTTPInfo(
            key: key,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Restores a deleted API key.  Restoring resets the `validity` attribute to `0`.  Algolia stores up to 1,000 API
    // keys per application. If you create more, the oldest API keys are deleted and can't be restored.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter key: (path) API key.
    // - returns: RequestBuilder<AddApiKeyResponse>

    open func restoreApiKeyWithHTTPInfo(
        key: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AddApiKeyResponse> {
        guard !key.isEmpty else {
            throw AlgoliaError.invalidArgument("key", "restoreApiKey")
        }

        var resourcePath = "/1/keys/{key}/restore"
        let keyPreEscape = "\(APIHelper.mapValueToPathItem(key))"
        let keyPostEscape = keyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{key}",
            with: keyPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter body: (body) The record. A schemaless object with attributes that are useful in the context of
    /// search and discovery.
    /// - returns: SaveObjectResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func saveObject(
        indexName: String,
        body: Codable,
        requestOptions: RequestOptions? = nil
    ) async throws -> SaveObjectResponse {
        let response: Response<SaveObjectResponse> = try await saveObjectWithHTTPInfo(
            indexName: indexName,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Adds a record to an index or replaces it.  - If the record doesn't have an object ID, a new record with an
    // auto-generated object ID is added to your index. - If a record with the specified object ID exists, the existing
    // record is replaced. - If a record with the specified object ID doesn't exist, a new record is added to your
    // index.
    // - If you add a record to an index that doesn't exist yet, a new index is created.  To update _some_ attributes of
    // a record, use the [`partial` operation](https://www.algolia.com/doc/rest-api/search/partial-update-object). To
    // add, update, or replace multiple records, use the [`batch`
    // operation](https://www.algolia.com/doc/rest-api/search/batch).  This operation is subject to [indexing rate
    // limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    // Required API Key ACLs:
    //  - addObject
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter body: (body) The record. A schemaless object with attributes that are useful in the context of search
    // and discovery.
    // - returns: RequestBuilder<SaveObjectResponse>

    open func saveObjectWithHTTPInfo(
        indexName: String,
        body: Codable,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SaveObjectResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "saveObject")
        }

        var resourcePath = "/1/indexes/{indexName}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter objectID: (path) Unique identifier of a rule object.
    /// - parameter rule: (body)
    /// - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func saveRule(
        indexName: String,
        objectID: String,
        rule: Rule,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await saveRuleWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            rule: rule,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // If a rule with the specified object ID doesn't exist, it's created. Otherwise, the existing rule is replaced.  To
    // create or update more than one rule, use the [`batch`
    // operation](https://www.algolia.com/doc/rest-api/search/save-rules).
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter objectID: (path) Unique identifier of a rule object.
    //
    // - parameter rule: (body)
    //
    // - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func saveRuleWithHTTPInfo(
        indexName: String,
        objectID: String,
        rule: Rule,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "saveRule")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "saveRule")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = rule
        let queryParameters: [String: Any?] = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter rules: (body)
    /// - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    /// - parameter clearExistingRules: (query) Whether existing rules should be deleted before adding this batch.
    /// (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func saveRules(
        indexName: String,
        rules: [Rule],
        forwardToReplicas: Bool? = nil,
        clearExistingRules: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await saveRulesWithHTTPInfo(
            indexName: indexName,
            rules: rules,
            forwardToReplicas: forwardToReplicas,
            clearExistingRules: clearExistingRules,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Create or update multiple rules.  If a rule with the specified object ID doesn't exist, Algolia creates a new
    // one. Otherwise, existing rules are replaced.  This operation is subject to [indexing rate
    // limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter rules: (body)
    //
    // - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    //
    // - parameter clearExistingRules: (query) Whether existing rules should be deleted before adding this batch.
    // (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func saveRulesWithHTTPInfo(
        indexName: String,
        rules: [Rule],
        forwardToReplicas: Bool? = nil,
        clearExistingRules: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "saveRules")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/batch"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = rules
        let queryParameters: [String: Any?] = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
            "clearExistingRules": clearExistingRules?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter objectID: (path) Unique identifier of a synonym object.
    /// - parameter synonymHit: (body)
    /// - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    /// - returns: SaveSynonymResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func saveSynonym(
        indexName: String,
        objectID: String,
        synonymHit: SynonymHit,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SaveSynonymResponse {
        let response: Response<SaveSynonymResponse> = try await saveSynonymWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            synonymHit: synonymHit,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // If a synonym with the specified object ID doesn't exist, Algolia adds a new one. Otherwise, the existing synonym
    // is replaced. To add multiple synonyms in a single API request, use the [`batch`
    // operation](https://www.algolia.com/doc/rest-api/search/save-synonyms).
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter objectID: (path) Unique identifier of a synonym object.
    //
    // - parameter synonymHit: (body)
    //
    // - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    // - returns: RequestBuilder<SaveSynonymResponse>

    open func saveSynonymWithHTTPInfo(
        indexName: String,
        objectID: String,
        synonymHit: SynonymHit,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SaveSynonymResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "saveSynonym")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "saveSynonym")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = synonymHit
        let queryParameters: [String: Any?] = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter synonymHit: (body)
    /// - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    /// - parameter replaceExistingSynonyms: (query) Whether to replace all synonyms in the index with the ones sent
    /// with this request. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func saveSynonyms(
        indexName: String,
        synonymHit: [SynonymHit],
        forwardToReplicas: Bool? = nil,
        replaceExistingSynonyms: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await saveSynonymsWithHTTPInfo(
            indexName: indexName,
            synonymHit: synonymHit,
            forwardToReplicas: forwardToReplicas,
            replaceExistingSynonyms: replaceExistingSynonyms,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // If a synonym with the `objectID` doesn't exist, Algolia adds a new one. Otherwise, existing synonyms are
    // replaced.  This operation is subject to [indexing rate
    // limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter synonymHit: (body)
    //
    // - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    //
    // - parameter replaceExistingSynonyms: (query) Whether to replace all synonyms in the index with the ones sent with
    // this request. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func saveSynonymsWithHTTPInfo(
        indexName: String,
        synonymHit: [SynonymHit],
        forwardToReplicas: Bool? = nil,
        replaceExistingSynonyms: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "saveSynonyms")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/batch"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = synonymHit
        let queryParameters: [String: Any?] = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
            "replaceExistingSynonyms": replaceExistingSynonyms?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter searchMethodParams: (body) Muli-search request body. Results are returned in the same order as the
    /// requests.
    /// - returns: SearchResponses
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func search<T: Codable>(
        searchMethodParams: SearchMethodParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchResponses<T> {
        let response: Response<SearchResponses<T>> = try await searchWithHTTPInfo(
            searchMethodParams: searchMethodParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Sends multiple search requests to one or more indices.  This can be useful in these cases:  - Different indices
    // for different purposes, such as, one index for products, another one for marketing content. - Multiple searches
    // to
    // the same index—for example, with different filters.  Use the helper `searchForHits` or `searchForFacets` to get
    // the results in a more convenient format, if you already know the return type you want.
    // Required API Key ACLs:
    //  - search
    //
    // - parameter searchMethodParams: (body) Muli-search request body. Results are returned in the same order as the
    // requests.
    // - returns: RequestBuilder<SearchResponses>

    open func searchWithHTTPInfo<T: Codable>(
        searchMethodParams: SearchMethodParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchResponses<T>> {
        let resourcePath = "/1/indexes/*/queries"
        let body = searchMethodParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter dictionaryName: (path) Dictionary type in which to search.
    /// - parameter searchDictionaryEntriesParams: (body)
    /// - returns: SearchDictionaryEntriesResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchDictionaryEntries(
        dictionaryName: DictionaryType,
        searchDictionaryEntriesParams: SearchDictionaryEntriesParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchDictionaryEntriesResponse {
        let response: Response<SearchDictionaryEntriesResponse> = try await searchDictionaryEntriesWithHTTPInfo(
            dictionaryName: dictionaryName,
            searchDictionaryEntriesParams: searchDictionaryEntriesParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for standard and custom dictionary entries.
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter dictionaryName: (path) Dictionary type in which to search.
    //
    // - parameter searchDictionaryEntriesParams: (body)
    // - returns: RequestBuilder<SearchDictionaryEntriesResponse>

    open func searchDictionaryEntriesWithHTTPInfo(
        dictionaryName: DictionaryType,
        searchDictionaryEntriesParams: SearchDictionaryEntriesParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchDictionaryEntriesResponse> {
        var resourcePath = "/1/dictionaries/{dictionaryName}/search"
        let dictionaryNamePreEscape = "\(APIHelper.mapValueToPathItem(dictionaryName))"
        let dictionaryNamePostEscape = dictionaryNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{dictionaryName}",
            with: dictionaryNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchDictionaryEntriesParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter facetName: (path) Facet attribute in which to search for values.  This attribute must be included in
    /// the `attributesForFaceting` index setting with the `searchable()` modifier.
    /// - parameter searchForFacetValuesRequest: (body)  (optional)
    /// - returns: SearchForFacetValuesResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchForFacetValues(
        indexName: String,
        facetName: String,
        searchForFacetValuesRequest: SearchForFacetValuesRequest? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchForFacetValuesResponse {
        let response: Response<SearchForFacetValuesResponse> = try await searchForFacetValuesWithHTTPInfo(
            indexName: indexName,
            facetName: facetName,
            searchForFacetValuesRequest: searchForFacetValuesRequest,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for values of a specified facet attribute.  - By default, facet values are sorted by decreasing count.  
    // You can adjust this with the `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have
    // **more than 65 searchable facets and searchable attributes combined**.
    // Required API Key ACLs:
    //  - search
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter facetName: (path) Facet attribute in which to search for values.  This attribute must be included in
    // the `attributesForFaceting` index setting with the `searchable()` modifier.
    //
    // - parameter searchForFacetValuesRequest: (body)  (optional)
    // - returns: RequestBuilder<SearchForFacetValuesResponse>

    open func searchForFacetValuesWithHTTPInfo(
        indexName: String,
        facetName: String,
        searchForFacetValuesRequest: SearchForFacetValuesRequest? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchForFacetValuesResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "searchForFacetValues")
        }

        guard !facetName.isEmpty else {
            throw AlgoliaError.invalidArgument("facetName", "searchForFacetValues")
        }

        var resourcePath = "/1/indexes/{indexName}/facets/{facetName}/query"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let facetNamePreEscape = "\(APIHelper.mapValueToPathItem(facetName))"
        let facetNamePostEscape = facetNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{facetName}",
            with: facetNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchForFacetValuesRequest
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter searchRulesParams: (body)  (optional)
    /// - returns: SearchRulesResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchRules(
        indexName: String,
        searchRulesParams: SearchRulesParams? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchRulesResponse {
        let response: Response<SearchRulesResponse> = try await searchRulesWithHTTPInfo(
            indexName: indexName,
            searchRulesParams: searchRulesParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for rules in your index.
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter searchRulesParams: (body)  (optional)
    // - returns: RequestBuilder<SearchRulesResponse>

    open func searchRulesWithHTTPInfo(
        indexName: String,
        searchRulesParams: SearchRulesParams? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchRulesResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "searchRules")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/search"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchRulesParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter searchParams: (body)  (optional)
    /// - returns: SearchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchSingleIndex<T: Codable>(
        indexName: String,
        searchParams: SearchSearchParams? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchResponse<T> {
        let response: Response<SearchResponse<T>> = try await searchSingleIndexWithHTTPInfo(
            indexName: indexName,
            searchParams: searchParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches a single index and returns matching search results as hits.  This method lets you retrieve up to 1,000
    // hits. If you need more, use the [`browse` operation](https://www.algolia.com/doc/rest-api/search/browse) or
    // increase the `paginatedLimitedTo` index setting.
    // Required API Key ACLs:
    //  - search
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter searchParams: (body)  (optional)
    // - returns: RequestBuilder<SearchResponse>

    open func searchSingleIndexWithHTTPInfo<T: Codable>(
        indexName: String,
        searchParams: SearchSearchParams? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchResponse<T>> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "searchSingleIndex")
        }

        var resourcePath = "/1/indexes/{indexName}/query"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter searchSynonymsParams: (body) Body of the `searchSynonyms` operation. (optional)
    /// - returns: SearchSynonymsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchSynonyms(
        indexName: String,
        searchSynonymsParams: SearchSynonymsParams? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchSynonymsResponse {
        let response: Response<SearchSynonymsResponse> = try await searchSynonymsWithHTTPInfo(
            indexName: indexName,
            searchSynonymsParams: searchSynonymsParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for synonyms in your index.
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter searchSynonymsParams: (body) Body of the `searchSynonyms` operation. (optional)
    // - returns: RequestBuilder<SearchSynonymsResponse>

    open func searchSynonymsWithHTTPInfo(
        indexName: String,
        searchSynonymsParams: SearchSynonymsParams? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchSynonymsResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "searchSynonyms")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/search"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchSynonymsParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter searchUserIdsParams: (body)
    /// - returns: SearchUserIdsResponse
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchUserIds(
        searchUserIdsParams: SearchUserIdsParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchUserIdsResponse {
        let response: Response<SearchUserIdsResponse> = try await searchUserIdsWithHTTPInfo(
            searchUserIdsParams: searchUserIdsParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    /// Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.  To
    /// ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every
    /// 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search
    /// will show an old value until the next time the mapping is rebuilt (every 12 hours).
    /// Required API Key ACLs:
    ///  - admin
    ///
    /// - parameter searchUserIdsParams: (body)
    /// - returns: RequestBuilder<SearchUserIdsResponse>
    @available(*, deprecated, message: "This operation is deprecated.")

    open func searchUserIdsWithHTTPInfo(
        searchUserIdsParams: SearchUserIdsParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchUserIdsResponse> {
        let resourcePath = "/1/clusters/mapping/search"
        let body = searchUserIdsParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter dictionarySettingsParams: (body)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func setDictionarySettings(
        dictionarySettingsParams: DictionarySettingsParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await setDictionarySettingsWithHTTPInfo(
            dictionarySettingsParams: dictionarySettingsParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Turns standard stop word dictionary entries on or off for a given language.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter dictionarySettingsParams: (body)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func setDictionarySettingsWithHTTPInfo(
        dictionarySettingsParams: DictionarySettingsParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        let resourcePath = "/1/dictionaries/*/settings"
        let body = dictionarySettingsParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Name of the index on which to perform the operation.
    /// - parameter indexSettings: (body)
    /// - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func setSettings(
        indexName: String,
        indexSettings: IndexSettings,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await setSettingsWithHTTPInfo(
            indexName: indexName,
            indexSettings: indexSettings,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Update the specified index settings.  Index settings that you don't specify are left unchanged. Specify `null` to
    // reset a setting to its default value.  For best performance, update the index settings before you add new records
    // to your index.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Name of the index on which to perform the operation.
    //
    // - parameter indexSettings: (body)
    //
    // - parameter forwardToReplicas: (query) Whether changes are applied to replica indices. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func setSettingsWithHTTPInfo(
        indexName: String,
        indexSettings: IndexSettings,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "setSettings")
        }

        var resourcePath = "/1/indexes/{indexName}/settings"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = indexSettings
        let queryParameters: [String: Any?] = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }

    /// - parameter key: (path) API key.
    /// - parameter apiKey: (body)
    /// - returns: UpdateApiKeyResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateApiKey(
        key: String,
        apiKey: ApiKey,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdateApiKeyResponse {
        let response: Response<UpdateApiKeyResponse> = try await updateApiKeyWithHTTPInfo(
            key: key,
            apiKey: apiKey,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Replaces the permissions of an existing API key.  Any unspecified attribute resets that attribute to its default
    // value.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter key: (path) API key.
    //
    // - parameter apiKey: (body)
    // - returns: RequestBuilder<UpdateApiKeyResponse>

    open func updateApiKeyWithHTTPInfo(
        key: String,
        apiKey: ApiKey,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdateApiKeyResponse> {
        guard !key.isEmpty else {
            throw AlgoliaError.invalidArgument("key", "updateApiKey")
        }

        var resourcePath = "/1/keys/{key}"
        let keyPreEscape = "\(APIHelper.mapValueToPathItem(key))"
        let keyPostEscape = keyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{key}",
            with: keyPostEscape,
            options: .literal,
            range: nil
        )
        let body = apiKey
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions
        )
    }
}
